% $Header:
% /home/vedranm/bitbucket/beamer/solutions/conference-talks/conference-ornate-20min.en.tex,v
% 90e850259b8b 2007/01/28 20:48:30 tantau $

\documentclass[8pt]{beamer}

% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.



% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 


\mode<presentation>
{
  \usetheme{Warsaw}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever
\usepackage{wasysym}
\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.
% \lstset{
%   language=XML,
%   basicstyle=\footnotesize,%\ttfamily,
%   columns=fullflexible,
%   morekeywords={encoding,
%     xs:schema,xs:element,xs:complexType,xs:sequence,xs:attribute}
% }

\title[Type reconstruction] {Type reconstruction}

\subtitle{constraint-based, unification and a little interpreter}

\author[Massimo Nocentini] % (optional, use only with lots of authors)
{Massimo~Nocentini\\\texttt{massimo.nocentini@gmail.com}}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

 \institute[UniversitaStudiFirenze] % (optional, but mostly needed)
 { Universit\`a degli Studi di Firenze }
%   \inst{1}%
%   Department of Computer Science\\
%   University of Somewhere
%   \and
%   \inst{2}%
%   Department of Theoretical Philosophy\\
%   University of Elsewhere}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[CoursePresentation] % (optional, should be abbreviation of conference name)
{Firenze, \today}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

\subject{Theory of Programming Languages}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=1.5cm]{university-logo}{logo/unifi}
% \logo{\pgfuseimage{university-logo}}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Contents}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}[plain]
  \titlepage
   \begin{center}
     \includegraphics[scale=.065]{logo/unifi}
   \end{center}
\end{frame}

\begin{frame}{Road map}
  \tableofcontents[pausesections]
  % You might wish to add the option [pausesections]
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\begin{frame}{Syntax review}
    \begin{block}{Terms}
        \begin{center}
            \begin{tabular}{ r l r }
              $t ::= $ & $x$ & \emph{variable} \\
               & $\lambda x:T.t$ & \emph{abstraction} \\
               & $t \, t$ & \emph{application} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Values}
        \begin{center}
            \begin{tabular}{ r l r }
              $v ::= $ & $\lambda x:T.t$ & \emph{abstraction value} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Types}
        \begin{center}
            \begin{tabular}{ r l r }
              $T ::= $ & $T \rightarrow T$ & \emph{function type} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Contexts}
        \begin{center}
            \begin{tabular}{ r l r }
              $\Gamma ::= $ & $\emptyset$ & \emph{empty context} \\
               & $\Gamma, x:T$ & \emph{variable binding} \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Evaluation rules review}
    \begin{block}{Evaluation rules}

        \begin{center}
            \begin{tabular}{ c r }
                    $\displaystyle {{t_{1} \rightarrow t_{1}^{\prime}}\over
                    {t_{1} \, t_{2} \rightarrow t_{1}^{\prime} \, t_{2}}}
                $ & (\emph{E-APP1}) \\ 
               & \\
               $\displaystyle{{t_{2} \rightarrow t_{2}^{\prime}}\over
                    {v_{1} \, t_{2} \rightarrow v_{1} \, t_{2}^{\prime}}}$ &
                         (\emph{E-APP2}) \\
               & \\ 
               $\displaystyle(\lambda x:T_{11}.t_{12})v_{2} \rightarrow 
                [x \mapsto v_{2}]t_{12}$ & (\emph{E-APPABS}) \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Typing rules review}
    \begin{block}{Typing rules}
        \begin{center}
            \begin{tabular}{ c r }
                    $\displaystyle {{x:T \in \Gamma}\over
                    {\Gamma \vdash x:T}} $ & (\emph{T-VAR}) \\ 
               & \\
               $\displaystyle{{\Gamma, x:T_{1} \vdash t_{2}:T_{2}}\over
                    {\Gamma \vdash \lambda x:T_{1}.t_{2} : T_{1} 
                        \rightarrow T_{2}}} $ & (\emph{T-ABS}) \\
               & \\ 
               $\displaystyle{{\Gamma \vdash t_{1}:T_{11} \rightarrow T_{12} \quad
                     \Gamma \vdash t_{2}:T_{11}}\over
                    {\Gamma \vdash t_{1} \, t_{2} : T_{12}}} $ & (\emph{T-APP}) \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\section{Introduction}

\subsection{Type variables and substitutions}

\begin{frame}{Introduction}
    Up to now we've worked with terms which all depends on
    \emph{explicit} type annotation, that is every $\lambda$-
    abstraction have to declare the \emph{concrete} type for the variable
    it introduce. \\~\\
    \pause
    It should be interesting to be ``lazy'' (in the fisical sense, not
    because we like to be some instance of a \emph{lazy} structures 
    \smiley) and say:
    \begin{center}
        ``I don't care to declare a \emph{concrete} type for my variable now,\\
        suspend the decision and call this type $X$, I'll specify it later''
    \end{center}
    \pause 
    Suppose we're deeply ``lazy'', why not apply the previous though
    to \emph{all} variables we introduce in our program? When are our terms 
    well typed if no concrete type is declared at all? \\~\\
    \pause
    In this lecture we'll see a method which allow us to be ``deeply lazy''
    while been able to type our meaningful terms and discard divergent ones
    (\texttt{lambda x.(x x)}, remember?)
\end{frame}

\begin{frame}{Augment type set with type variables}
    In order to leave unspecified the type for a variable we've to augment
    our language with a new type category, which we'll call \emph{type
    variables}, written as $\mathcal{A}$:
    \begin{block}{Types - augmented with type variables}
        \begin{center}
            \begin{tabular}{ r l l }
              $T ::= $ & $T \rightarrow T$ & \emph{function type} \\
               & $\mathcal{A}$ & \emph{type variable} \\
              $\mathcal{A} ::= $ & $\{A,B,\ldots,X_{i \in \mathbb{N}},
                \ldots \}$ & \emph{type variables} \\
            \end{tabular}
        \end{center}
    \end{block}
    \pause
    Let $X \in \mathcal{A}$:
    \begin{itemize}
        \item there's no typing rule that uses the category $\mathcal{A}$
        \item $X$ can represent a \emph{basic} type
            (ie. \texttt{Bool}, \texttt{Nat}, \ldots) or another 
            unspecified type
        \item $X$, being a type, can be used by the defined typing rules
        \item $X \not = Y, \forall Y \in \mathcal{A} \setminus \{X\}$, 
            in other words, $\mathcal{A}$ is infinite and types represented
            by different type variables are different too
    \end{itemize}
    \pause
    \begin{example}
        \begin{displaymath}
            \begin{split}
                \Gamma &\vdash \lambda x:X.x : X \rightarrow X\\
                \Gamma &\vdash \lambda x:A.x : A \rightarrow A\\
                \Gamma &\vdash \lambda s:S. \lambda z: Z. (s\, (s\, z)) : 
                    (Z \rightarrow Z) \rightarrow Z \rightarrow Z\\
            \end{split}
        \end{displaymath}
    \end{example}
\end{frame}

\begin{frame}{Substitutions}
    \begin{center}
        ``I'd like that type variable $X$ in my term $t$ to stands for 
        \texttt{Nat} type. \\Is it possible to do a \emph{substitution}?''
    \end{center}

    \pause
    \begin{block}{Definition of substitution}
        A \emph{type substitution} $\sigma$ is a mapping $\sigma: \mathcal{A}
        \rightarrow T$ \\~\\
        A \emph{substitution application} $\sigma T_{1}$ 
        of a type substitution $\sigma$ to a type $T_{1}$ is defined 
        inductively on the structure of types:
        \begin{displaymath}
            \begin{split}
                X \in \mathcal{A} \wedge \exists T_1: (X \mapsto T_{1}) 
                    \in \sigma & \rightarrow \sigma X = T_{1} \\ 
                X \in \mathcal{A} \wedge \forall T_1: (X \mapsto T_{1}) 
                    \not \in \sigma & \rightarrow \sigma X = X \\ 
                T_{1} \text{ is a concrete type } &\rightarrow  
                    \sigma T_{1} = T_{1}\\
                T_{1}, T_{2} \in T & \rightarrow \sigma(T_{1} \rightarrow 
                    T_{2}) = \sigma T_{1} \rightarrow \sigma T_{2} \\ 
            \end{split}
        \end{displaymath}
    \end{block}
    \pause
    For the following it is useful to introduce two combinations 
    (let $\mathcal{C}$ is a set of contexts):
    \begin{itemize}
        \item $\Gamma = \{ x_1:T_1, \ldots, x_n:T_n\} \in \mathcal{C} 
            \rightarrow \sigma\Gamma = (x_1:\sigma T_1, \ldots,
                x_n:\sigma T_n) \in \mathcal{C}$
        \item let $\sigma, \gamma$ be two type substitutions, their
            composition $\sigma \circ \gamma$ is defined as follows:
            \begin{displaymath}
                \begin{split}
                    \sigma \circ \rho &= \{X \mapsto \sigma T_1 | \,
                        \forall T_1:(X \mapsto T_1) \in \rho \} \\
                    \sigma \circ \rho &= \{X \mapsto T_1 |\, 
                        \forall T_{1}:(X \mapsto T_1) \in \sigma \wedge
                            \forall T_{2}:(X \mapsto T_2) \not \in \rho\} \\
                \end{split}
            \end{displaymath}
            
    \end{itemize}
\end{frame}

\begin{frame}{Typing relation is closed under substitution application}
    \begin{theorem}
        Let $\sigma$ be a type substitution, $\Gamma$ a context, 
        $T_1 \in T$ and $t$ a term. Then:
        \begin{displaymath}
            \Gamma \vdash t:T_1 \rightarrow \sigma\Gamma \vdash \sigma t: \sigma T_1
        \end{displaymath}
    \end{theorem}
    \begin{proof}
        TODO
    \end{proof}
\end{frame}

\subsection{Parametric polymorphism and type inference}

\begin{frame}{Parametric Polymorphism}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    A first question arises:
    \begin{itemize}
        \item $\forall \sigma. \exists T_1: 
            \sigma \Gamma \vdash \sigma t : T_1$\\
            {\footnotesize Do all type sustitution $\sigma$ makes the term 
                $\sigma t$ typeable under assumption $\sigma \Gamma$?}\\~\\
            If this is the case, why not write \emph{any} concrete type
            using a type variable and use a substitution to obtain the 
            original one? 
            \pause
            \begin{example}
                Write $\lambda s:Z \rightarrow Z.\lambda z:Z.(s\, (s\, z))$
                instead of $\lambda s:Nat \rightarrow Nat.
                    \lambda z:Nat.(s\, (s\, z))$ \\~\\
                For example, if we work with concrete type $String$ just use 
                $\sigma = \{Z \mapsto String\} $
            \end{example}
            \pause
            Holding type variables abstract during type checking is called
            \emph{parametric polymorphism}: type variables are used to allow
            a term in which they appear usable in many concrete contexts
    \end{itemize}
\end{frame}

\begin{frame}{Type inference}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    A second question arises:
    \begin{itemize}
        \item $\exists \sigma. \exists T_1: 
            \sigma \Gamma \vdash \sigma t : T_1$\\
            {\footnotesize Is it always possible to find a type 
                sustitution $\sigma$ such that the term 
                $\sigma t$ is typeable under assumption $\sigma \Gamma$?}\\~\\
            If this is the case, suppose $\not \exists T_{1}.
            \Gamma \not \vdash t:T_1$, using 
            type substitution $\sigma$ we're able to give a type $T_{2}$ 
            to $\sigma t$, formally $\sigma \Gamma \vdash \sigma t: T_{2}$
            \pause
            \begin{example}
                $\lambda s:S.\lambda z:Z.(s\, (s\, z))$ 
                has {\color{red} no} type, $\forall S,Z \in \mathcal{A}$\\~\\
                but it has type if we use $\sigma = \{
                    S \mapsto Nat \rightarrow Nat, Z \mapsto Nat\}$ or
                    $\sigma = \{S \mapsto Z \rightarrow Z\}$
            \end{example}
            \pause
            Looking for valid ``instantiations'' of type variables is called
            \emph{type inference}: the compiler fill in type information 
            wherever the user don't specify them
    \end{itemize}
\end{frame}

\subsection{Definition of solution for $(\Gamma, t)$}

\begin{frame}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    \begin{block}{Definition of \emph{solution} for $(\Gamma, t)$}
        Let $\sigma$ be a type substitution and $T_{1} \in T$.\\
        A  \emph{solution} for $(\Gamma, t)$ is a pair $(\sigma, T_{1})$
        such that $\sigma \Gamma \vdash \sigma t:T_{1}$
    \end{block}
    \pause
    \begin{example}
        Let $\Gamma = \{f:X, a:Y\}$ and $t = f\, a$ then:
        \begin{displaymath}
            ([X \mapsto Nat \rightarrow Nat, Y \mapsto Nat], Nat) \quad 
            ([X \mapsto Y \rightarrow Z], Z)
        \end{displaymath}
        are both solutions for $(\Gamma, t)$.
    \end{example}
\end{frame}

\section{Constrait-based typing}
\subsection{Constraint set and relations}
\begin{frame}
    Questions:
    \begin{itemize}
        \item During an execution of a type-checking algorithm, why
                    not record constraints of the form $S_i = T_i$ instead 
                    to actually perform a type comparison?
        \item As we've seen in the last example, there exists countable 
                    solutions for a pair $(\Gamma, t)$, are they related in 
                    some way? 
    \end{itemize}
    \pause
    \begin{block}{Definition of \emph{constraint set} 
                    and \emph{unify} relation}
        A \emph{constraint set} $\mathcal{C}$ is a set of equations 
        $\{S_i \triangleq T_i \}_{i \in \mathbb{N}}$ such that 
        $\mathcal{C} \subseteq T \times T$
        \\~\\
        A type substitution $\sigma$ \emph{unify} an equation 
        $S \triangleq T$, written as $\sigma \Join S \triangleq T$, 
        if $\sigma S = \sigma T$
        \\~\\
        Extending the unification relation to constraint sets, a type substitution
        $\sigma$ \emph{unify} a constraint set $\mathcal{C}$, written as 
        $\sigma \Join \mathcal{C}$, if $\forall (S \triangleq T)
        \in \mathcal{C}: \sigma \Join (S \triangleq T)$ 
    \end{block}
    \pause
    Answers:
    \begin{itemize}
        \item The modified type checking algorithm prove that a 
            term $t$ has type $T_1$ under assumptions $\Gamma$ 
            whenever there exists a type substitution $\sigma$ such that 
            $\sigma \Join \mathcal{C}$
        \item let $\mathcal{C}$ be a constraint set for a pair $(\Gamma, t)$.
            Two solutions $(\sigma_1,T_1)$ and $(\sigma_2,T_2)$ are related if  
            $\sigma_1 \Join \mathcal{C}$ and $\sigma_2 \Join \mathcal{C}$ 
    \end{itemize}
\end{frame}


\begin{frame}
    Let's see an example of how we collect a constraint $S \triangleq T$
    \begin{example}
        Suppose to have an application term $t_1 t_2$ with $\Gamma \vdash t_1 : T_1$
        and $\Gamma \vdash t_2 : T_2$ \\~\\
        Instead of checking:
        \begin{itemize}
            \item $T_1$ has the form $T_2 \rightarrow T_{12}$, for some $T_{12}$
            \item $t_1 t_2$ has type \emph{exactly} $T_{12}$
        \end{itemize}
        We suspend a decision for the type $T_{12}$, abstracting it with a 
        \emph{fresh} type variable $X$, creating the constraint 
        $T_1 \triangleq T_2 \rightarrow X$ (hence $t_1 t_2$
        has type $X$ from now on!)
    \end{example}
    \pause
    The following questions drive what follow:
    \begin{itemize}
        \item given a pair $(\Gamma, t)$ there always exist a constraint set?
        \item suppose a constraint exists, is it unique?
        \item assume the existence is enough, how is its construction defined?
        \item how can we use the constraint set to build a solution for $(\Gamma, t)$?
    \end{itemize}
\end{frame}

\subsection{Constraint typing relation}

\begin{frame}
    \begin{block}{Definition of \emph{constraint typing relation} 
            $\Gamma \vdash t : T_1 \; \textbar_\mathcal{X} \; \mathcal{C}$}
        The \emph{constraint typing relation} where a term $t$ has type
            $T_1$ under assumptions $\Gamma$ 
            whenever exists a type substitution $\sigma$ such that 
            $\sigma \Join \mathcal{C}$, written as
            $\Gamma \vdash t : T_1 \textbar_\mathcal{X} \mathcal{C}$,
            is defined inductively as follow:
            \begin{center}
                \begin{tabular}{ c r }
                        $\displaystyle {{x:T \in \Gamma}\over
                        {\Gamma \vdash x:T \; \textbar_{\emptyset}\;  \emptyset}} $ 
                            & (\emph{CT-VAR}) \\ 
                   & \\
                   $\displaystyle{{\Gamma, x:T_{1} \vdash t_{2}:T_{2}\;
                    \textbar_{\mathcal{X}} \; \mathcal{C} }\over
                        {\Gamma \vdash \lambda x:T_{1}.t_{2} : T_{1} 
                            \rightarrow T_{2}\;
                    \textbar_{\mathcal{X}} \; \mathcal{C} }} $ & (\emph{CT-ABS}) \\
                   & \\ 
                   ${\displaystyle{{{
                        \begin{array}{rl}
                         \text{let} & X \text{ be fresh variable} \\
                        \Gamma \vdash & t_{1}:T_{1} \; \textbar_{\mathcal{X}_1} \;
                            \mathcal{C}_1  \\
                        \Gamma \vdash & t_{2}:T_{2} \; \textbar_{\mathcal{X}_2} \;
                            \mathcal{C}_2  \\
                         \mathcal{C}^{\prime} = & \mathcal{C}_1 \cup \mathcal{C}_2
                            \cup \{ T_1 \triangleq T_2 \rightarrow X \}
                        \end{array}}\over
                        {\Gamma \vdash t_{1} \, t_{2} : X\;
                    \textbar_{\mathcal{X}_1 \cup \mathcal{X}_2 \cup
                        \{X\}} \; \mathcal{C}^{\prime} }}}} $ & (\emph{CT-APP}) \\
                \end{tabular}
            \end{center}
        The set $\mathcal{X}$ is used to track type variables introduced
            by applications of rule \emph{CT-APP}
    \end{block}
\end{frame}

\begin{frame}
    \begin{example}
    \end{example}
\end{frame}

\subsection{Definition of solution for $(\Gamma, t, S, \mathcal{C})$}

\begin{frame}
    It is helpful make the following observations:
    \begin{itemize}
        \item when a type variable $X$ is choosen by a final rule which has
            some premises, then $X$ is different from all other type variables
            introduced by premises' subderivations
        \item for any given pair $(\Gamma, t)$ the rules provide a procedure to 
            build sets $\mathcal{X}, \mathcal{C}$ and find type $T_1$ such that
            $\Gamma \vdash t : T_1 \; \textbar_\mathcal{X} \; \mathcal{C}$
        \item if we consider the relation  
            $\Gamma \vdash t : T_1 \; \textbar_\mathcal{X} \; \mathcal{C}$ modulo
            the choice of fresh variables, then the constraint set $\mathcal{C}$ and
            type $T_1$ are \emph{uniquely} determined
        \item in order to find solutions for $(\Gamma, t)$ we use the given rules to:
            \begin{enumerate}
                \item build the constraint set $\mathcal{C}$, that
                    must be satisfied in order for $t$ to have a type
                \item determine a type $S$ possibly containing type variables (which are 
                    subjects under constraints in $\mathcal{C}$), which caracterizes
                    the types of $t$ in terms of these variables
                \item find a type sustitution $\sigma$ such that $\sigma \Join 
                    \mathcal{C}$: for each such $\sigma$ the type $\sigma S$ is
                    a possible type for $t$, hence $(\sigma, \sigma S)$ 
                    is a solution for $(\Gamma, t)$
                \item if no type sustitution $\sigma \Join \mathcal{C}$ exists then
                    there is no way to instantiate type variables in $t$ in order
                    for $t$ to have a type.
            \end{enumerate}
    \end{itemize}
\end{frame}


\begin{frame}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    \begin{block}{Definition of \emph{solution} for $(\Gamma, t, S, \mathcal{C})$}
        Let $\sigma$ be a type substitution and $T_{1} \in T$ and suppose
            $\Gamma \vdash t : T_1 \; \textbar_\mathcal{X} \; \mathcal{C}$ \\
        A  \emph{solution} for $(\Gamma, t, S, \mathcal{C})$ is a pair 
        $(\sigma, T_{1})$ such that $\sigma \Join \mathcal{C} \wedge \sigma S = T_1$
    \end{block}
    \pause
    \begin{example}
        Let $t = \lambda x:X\rightarrow Y. x \, 0$ then:
        \begin{displaymath}
            \begin{split}
                S &= (X \rightarrow Y) \rightarrow Z \\
                \mathcal{C} &= \{Nat \rightarrow Z \triangleq X \rightarrow Y\}\\
                \sigma &= \{X \mapsto Nat, Z \mapsto Bool, Y \mapsto Bool\}\\
            \end{split}
        \end{displaymath}
        hence $(\sigma, (Nat \rightarrow Bool) \rightarrow Bool)$ is a solution 
        for $(\Gamma, t, S, \mathcal{C})$.
    \end{example}
\end{frame}

\section{Unification}

\section{Limitations, worst-cases and complexity}

\section{Interpreter}

\subsection{Lambda calculus grammar}

\begin{frame}{Grammar}
  \begin{block}{Definizione}
    The set T of terms representing the lambda calculus language is the
    smallest set generated by the following rules:
  \begin{displaymath}
    \begin{split}
      \text{Term} &\triangleq \text{AppTerm | ``lambda'' ID ``:'' Type ``.''
        ATerm}\\
      \text{AppTerm} &\triangleq \text{ATerm ATerm} \\
      \text{ATerm} &\triangleq \text{``('' Term ``)'' | ID}\\
      \text{Type} &\triangleq \text{ArrowType}\\
      \text{AType} &\triangleq \text{``('' Type ``)'' | ``Bool'' |
        ``Nat'' | ID}\\
      \text{ArrowType} &\triangleq \text{AType} (\rightarrow
      \text{ArrowType} | \text{AType})\\
    \end{split}
  \end{displaymath}
\end{block}
where:
\begin{itemize}
    \item $\Sigma$ is our alphabet;
    \item ID $\in \Sigma \setminus \{ \text{``lambda'', ``:'', ``.'',
  ``('', ``)'', ``Bool'', ``Nat''} \}$.
\end{itemize}

%\begin{center}
%  \includegraphics[scale=0.4]{images/graph-with-b-setted.eps}
%  \includegraphics[scale=0.4]{images/story-example.eps} 
%  \includegraphics[scale=0.4]{images/non-story-example.eps}
%\end{center} 
\end{frame}

\begin{frame}{Some observations}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
    We make the following observations:
      \begin{itemize}
        \item we design the grammar to be processed by \emph{ANTLR}, a $LL(k)$
            top-down parser;
        \item the grammar seen during lectures has left recursion on 
            $T-APP$ rule (good for LR bottom-up parser);
        \item our grammar maybe ``naive'' in the sense that allow to write 
            some strange terms (ie: \texttt{x (lambda y:Y. x)}) but for our 
            scope is enough;
        \item it allows to write some ``obscure'' terms (ie: 
            \texttt{lambda x:X.(x x)}) which we desire to prove not safe.
    \end{itemize}
\end{frame}

\subsection{Term substitution issues}

\begin{frame}{Substitution definition - first attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} \\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{The names of bound variables do not matter}
        \begin{displaymath}
            \begin{split}
                [x \mapsto (\lambda z. z\, w)](\lambda y.x) &=
                     \lambda y.\lambda z.z\, w \quad \smiley \\
                [x \mapsto y](\lambda x.x) &= \lambda x.y \quad \frownie
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    We've not distinguished between \emph{free} occurrences of $x$ in a term $t$,
    which should get replaced during substitution, and \emph{bound} ones, which
    shouldn't.
\end{frame}

\begin{frame}{Substitution definition - second attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= {\color{red} \lambda y. t_{1} 
                    \quad \text{if } x = y}\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                    \quad {\color{red} \text{if } x \not = y}\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{Variable capture}
        \begin{displaymath}
            \begin{split}
                [x \mapsto y](\lambda x.x) &= \lambda x.x \quad \smiley \\
                [x \mapsto z](\lambda z.x) &= \lambda z.z \quad \frownie\\ 
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    To avoid it, we need to make sure that the bound variable names of $t$
    are kept distinct from the free variables of $s$.
\end{frame}

\begin{frame}{Substitution definition - third attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. t_{1} \quad 
                    \text{if } x = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                                    \quad \text{if } x \not = y 
                                    {\color{red}\wedge y \not \in FV(s)}\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{$[x \mapsto s]t$ isn't a total function}
        \begin{displaymath}
            \begin{split}
                [x \mapsto z](\lambda z.x) &\not = \lambda z.z \quad \smiley\\ 
                [x \mapsto z](\lambda z.x) &\quad \text{yields no term at all!} 
                    \quad \frownie\\
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    A common fix is to work with terms \emph{up to renaming of bound variables}.
\end{frame}

\begin{frame}{Substitution definition - final attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \begin{block}{Observation}
        Terms that differ only in the names of bound variables are 
        interchangeable in all contexts.
    \end{block}

    \pause

    Any $\lambda$-bound variable can be changed to another name (changing the body 
    consistently too) at any point where this is convenient.

    \begin{example}
        \begin{displaymath}
            \begin{split}
                [x \mapsto y \, z](\lambda y.x \, y) &
                    \text{ renames abstraction to } (\lambda w.x \, w)\\ 
                [x \mapsto y \, z](\lambda w.x \, w) &= \lambda w. y \, z \, w 
                    \quad \smiley\\
            \end{split}
        \end{displaymath}
    \end{example}

    \pause

    This observation makes $[x \mapsto s]t$ a total function: 
    whenever we have to apply it to arguments for which it is 
    undefined, we can rename the $\lambda$ abstraction bound variable
    in order to satisfy side conditions.
\end{frame}

\begin{frame}{Substitution definition - final attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                                    \quad \text{if } x \not = y 
                                    \wedge (y \not \in FV(s) 
                                    {\color{red} \text{ by renaming}})\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}
\end{frame}

\subsection{Nameless representation of terms}

\begin{frame}{De Bruijn's idea}
    Up to now we've worked with terms \emph{up to renaming of bound 
    variables}. This does mean that an abstraction term is a \emph{schema}
    term indeed, which could represent \emph{infinite} terms.
    \begin{displaymath}
        \lambda x:T.t \text{ is a term} \leftrightarrow 
            \forall x \not \in FV(t)
    \end{displaymath}
    \begin{itemize}
        \item it is good for theoretical reasoning \smiley
        \item do not supply a single representation of terms \frownie
    \end{itemize}
    \pause
    \begin{block}{De Bruijn's idea}
        Variable occurrences \emph{point} to their binders, rather 
        than referring to them by name.
    \end{block}
    Using this idea we abstract from \emph{variable names}, replacing names by
    natural numbers. Let $k \in \mathbb{N}$ then $k$ represents \emph{the variable 
    bound by the $k$-th enclosing $\lambda$, counting from the most nested abstraction}.
    \pause
    \begin{example}
        \begin{displaymath}
            \begin{split}
                \lambda x.x \quad & \text{transforms to} \quad \lambda.0\\
                \lambda s.\lambda z.s \, (s\,  z) \quad & 
                    \text{transforms to} \quad \lambda.\lambda.1\,  (1\,  0)
            \end{split}
        \end{displaymath}
    \end{example}
\end{frame}

\begin{frame}{New definition of terms}
    The new definition of \emph{nameless} terms is similar to the one given 
    before, the only difference is that we need to track of how many free
    variables can appear in each term.

    \begin{block}{Definition}
        The set of terms is defined as the smallest family of sets
        $\{\mathcal{T}_{0},\mathcal{T}_{1},\ldots\}$ such that:
        \begin{displaymath}  
           \begin{split} 
                k \in \{0, \ldots, n-1\} &\rightarrow k \in \mathcal{T}_n  \\
                t_{1} \in \mathcal{T}_{n+1} &\rightarrow \lambda.t \in \mathcal{T}_n  \\
                t_{1} \in \mathcal{T}_{n} \wedge t_{2} \in \mathcal{T}_{n}
                    &\rightarrow t_{1} \, t_{2} \in \mathcal{T}_n  \\
           \end{split} 
        \end{displaymath}  
    \end{block}
    For all $j \in \mathcal{T}_n$ we say that $j$ is a $n$-term and in $j$ 
    appear \emph{at most} $n$ different free variables (pay attention: this is
    not a constraint on the number of \emph{occurrences} of the free variables, that is
    $\lambda.\lambda.(3\, (3\, (1\, (2\, (0\, 3)))))\, ((3\, 1)\, 3) 
        \in \mathcal{T}_{4}$ where there are 6 free variables).
\end{frame}

\begin{frame}
    
    \begin{itemize}
        \item two ordinary terms $t_1, t_2$ are equivalent modulo renaming of bound 
            $\leftrightarrow$ $t_{1}, t_{2}$ have the same nameless 
            representation \smiley
        \item how to deal with terms containing free variables, 
            ie $\lambda x.y\, x$?\\
            {\footnotesize We know how far the binder of $x$ is , but we doesn't 
            for the binder of $y$...}
    \end{itemize}
    \pause
    \begin{block}{Naming context}
        A naming context is an assignment of natural numbers to variables names,
        more formally:
       \begin{displaymath} 
            \Gamma \subseteq \mathcal{V} \times \mathbb{N} 
       \end{displaymath} 
       where $\mathcal{V}$ is the set of variables.
    \end{block}
    \pause
    \begin{example}
        Let $\Gamma = \{ x \mapsto 4, y \mapsto 3, z \mapsto 2, a \mapsto 1, 
                        b \mapsto 0 \}$ be a naming context. We have:
        \begin{displaymath}
            \begin{split}
                x \, (y \, z) \quad &\text{transforms to} \quad 4 \, (3 \, 2)\\
                \lambda w.y \, w \quad &\text{transforms to} \quad 
                    \lambda. 4 \, 0 \quad (4?!)\\
                \lambda w.\lambda a.x \quad &\text{transforms to} \quad 
                    \lambda.\lambda. 6\quad (6?!)\\
            \end{split}
        \end{displaymath}
    \end{example}
\end{frame}

\begin{frame}{Shifting and substitution}
    Consider \emph{again} the rule:
        $(\lambda x.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$ 
        where $t_{12} = \lambda y.t, x\not=y$.
    \\~\\
    \pause
    
    When we can apply the substitution $[x \mapsto s]$ to an abstraction $\lambda.t$
    the context in which the substitution is happening introduces a $\lambda$, 
    in other word introduces a variable. \\
    \begin{block}{Shifting}
        In order to remain consistent within $s$, we have to increment the indices of 
        free variables appearing in $s$ by one, since we're introducing a 
        $\lambda$ binder between the free variables in $s$ and their binders.
        We call this increment operation, or \emph{shifting}, with $\uparrow^{1}(s)$.
    \end{block}
    \pause
    For the same reason that the abstraction $\lambda.t$ introduces a variable,
    we've to modify the definition of $[x \mapsto s]$, paying attention to increment
    x by one too because x isn't the variable bound by the context $\lambda.t$.
\end{frame}

\begin{frame}
    \begin{block}{Formal Substitution definition}
        The substitution of a term $s$ for a variable number $j$ in a term $t$,
        written as $[j \mapsto s]t$, is defined inductively as follows:
        \begin{displaymath}
            \begin{split}
                [j \mapsto s]k &= s \quad \text{if } k = j\\
                [j \mapsto s]k &= k \quad \text{if } k \not= j\\
                [j \mapsto s]\lambda.t_{1} &= 
                    \lambda.[j+1 \mapsto \uparrow^{1}(s)]t_{1} \\
                [j \mapsto s]t_1 \, t_2 &= ([j \mapsto s] t_1)\, ([j \mapsto s] t_2)
            \end{split}
        \end{displaymath}
    \end{block}
    \pause 
    \begin{block}{Formal Shifting definition}
        The $d$-place shift of a term $t$ above cutoff $c$,
        written as $\uparrow_{c}^{d}(t)$, is defined inductively as follows
        (where $\uparrow^{d}(t)$ stands for $\uparrow_{0}^{d}$):
        \begin{displaymath}
            \begin{split}
                \uparrow_{c}^{d}(k) &= k \quad \text{if } k < c\\
                \uparrow_{c}^{d}(k) &= k+d \quad \text{if } k \geq c\\
                \uparrow_{c}^{d}(\lambda.t_{1}) &= 
                    \lambda.\uparrow_{c+1}^{d}(t_{1}) \\
                \uparrow_{c}^{d}(t_1 \, t_2) &= \uparrow_{c}^{d}(t_1)\, 
                    \uparrow_{c}^{d}(t_2)
            \end{split}
        \end{displaymath}
    \end{block}
\end{frame}

\begin{frame}{Evaluation}
    Consider \emph{for the last time} the rule:
        $(\lambda x.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$ 
        where $t_{12} = \lambda y.t, x\not=y$.
    \\~\\
    \pause
    Reducing an abstraction $\lambda x.t_{12}$ make disappear the bound 
    variable $x$, so the resulting term $[x \mapsto v_{2}]t_{12}$ belong to 
    a smaller context (respect the number of $\lambda$ binders), hence we have to
    shift its free variables \emph{backward} by one.
    \\~\\
    \pause
    Similarly, in the resulting term we've to shift free 
    variables in $v_{2}$ \emph{forward} by one
    because the term $t_{12}$ is defined in a larger context (is protected by
    a $\lambda$-abstraction).
    \\~\\
    \pause
    Finally, we're interested to start substituting the inner most bound
    variable since this is our reduction strategy, so the initial index
    given to substitution function is $0$.
    \\~\\
    \pause
    \begin{block}{Modified reduction rule}
        \begin{displaymath}
            (\lambda.t_{12})\, v_{2} \rightarrow \uparrow^{-1}(
            [0 \mapsto \uparrow^{1}(v_{2})]t_{12})
        \end{displaymath}
    \end{block}
\end{frame}


\end{document}


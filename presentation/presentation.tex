% $Header:
% /home/vedranm/bitbucket/beamer/solutions/conference-talks/conference-ornate-20min.en.tex,v
% 90e850259b8b 2007/01/28 20:48:30 tantau $

\documentclass[8pt]{beamer}

% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.



% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 


\mode<presentation>
{
  \usetheme{Warsaw}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever
\usepackage{wasysym}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{cancel}
\newcommand\xxcancel[1]{\xcancel{#1}\vphantom{#1}}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.
% \lstset{
%   language=XML,
%   basicstyle=\footnotesize,%\ttfamily,
%   columns=fullflexible,
%   morekeywords={encoding,
%     xs:schema,xs:element,xs:complexType,xs:sequence,xs:attribute}
% }

\title[Type reconstruction] {Type reconstruction}

\subtitle{constraint-based, unification and a little interpreter}

\author[Massimo Nocentini] % (optional, use only with lots of authors)
{Massimo~Nocentini\\\texttt{massimo.nocentini@gmail.com}}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

 \institute[UniversitaStudiFirenze] % (optional, but mostly needed)
 { Universit\`a degli Studi di Firenze }
%   \inst{1}%
%   Department of Computer Science\\
%   University of Somewhere
%   \and
%   \inst{2}%
%   Department of Theoretical Philosophy\\
%   University of Elsewhere}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[CoursePresentation] % (optional, should be abbreviation of conference name)
{Firenze, \today}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

\subject{Theory of Programming Languages}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=1.5cm]{university-logo}{logo/unifi}
% \logo{\pgfuseimage{university-logo}}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Contents}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}[plain]
  \titlepage
   \begin{center}
     \includegraphics[scale=.065]{logo/unifi}
   \end{center}
\end{frame}

\begin{frame}{Road map}
  \tableofcontents[pausesections]
  % You might wish to add the option [pausesections]
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\begin{frame}{Syntax review}
    \begin{block}{Terms}
        \begin{center}
            \begin{tabular}{ r l r }
              $t ::= $ & $x$ & \emph{variable} \\
               & $\lambda x:T.t$ & \emph{abstraction} \\
               & $t \, t$ & \emph{application} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Values}
        \begin{center}
            \begin{tabular}{ r l r }
              $v ::= $ & $\lambda x:T.t$ & \emph{abstraction value} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Types}
        \begin{center}
            \begin{tabular}{ r l r }
              $T ::= $ & $T \rightarrow T$ & \emph{function type} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Contexts}
        \begin{center}
            \begin{tabular}{ r l r }
              $\Gamma ::= $ & $\emptyset$ & \emph{empty context} \\
               & $\Gamma, x:T$ & \emph{variable binding} \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Evaluation rules review}
    \begin{block}{Evaluation rules}

        \begin{center}
            \begin{tabular}{ c r }
                    $\displaystyle {{t_{1} \rightarrow t_{1}^{\prime}}\over
                    {t_{1} \, t_{2} \rightarrow t_{1}^{\prime} \, t_{2}}}
                $ & (\emph{E-APP1}) \\ 
               & \\
               $\displaystyle{{t_{2} \rightarrow t_{2}^{\prime}}\over
                    {v_{1} \, t_{2} \rightarrow v_{1} \, t_{2}^{\prime}}}$ &
                         (\emph{E-APP2}) \\
               & \\ 
               $\displaystyle(\lambda x:T_{11}.t_{12})v_{2} \rightarrow 
                [x \mapsto v_{2}]t_{12}$ & (\emph{E-APPABS}) \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Typing rules review}
    \begin{block}{Typing rules}
        \begin{center}
            \begin{tabular}{ c r }
                    $\displaystyle {{x:T \in \Gamma}\over
                    {\Gamma \vdash x:T}} $ & (\emph{T-VAR}) \\ 
               & \\
               $\displaystyle{{\Gamma, x:T_{1} \vdash t_{2}:T_{2}}\over
                    {\Gamma \vdash \lambda x:T_{1}.t_{2} : T_{1} 
                        \rightarrow T_{2}}} $ & (\emph{T-ABS}) \\
               & \\ 
               $\displaystyle{{\Gamma \vdash t_{1}:T_{11} \rightarrow T_{12} \quad
                     \Gamma \vdash t_{2}:T_{11}}\over
                    {\Gamma \vdash t_{1} \, t_{2} : T_{12}}} $ & (\emph{T-APP}) \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\section{Introduction}

\subsection{Type variables and substitutions}

\begin{frame}{Introduction}
    Up to now we've worked with terms which all depends on
    \emph{explicit} type annotation, that is every $\lambda$-
    abstraction have to declare the \emph{concrete} type for the variable
    it introduce. \\~\\
    \pause
    It should be interesting to be ``lazy'' (in the fisical sense, not
    because we like to be some instance of a \emph{lazy} structures 
    \smiley) and say:
    \begin{center}
        ``I don't care to declare a \emph{concrete} type for my variable now,\\
        suspend the decision and call this type $X$, I'll specify it later''
    \end{center}
    \pause 
    Suppose we're deeply ``lazy'', why not apply the previous though
    to \emph{all} variables we introduce in our program? When are our terms 
    well typed if no concrete type is declared at all? \\~\\
    \pause
    In this lecture we'll see a method which allow us to be ``deeply lazy''
    while been able to type our meaningful terms and discard divergent ones
    (\texttt{lambda x.(x x)}, remember?)
\end{frame}

\begin{frame}{Augment type set with type variables}
    In order to leave unspecified the type for a variable we've to augment
    our language with a new type category, which we'll call \emph{type
    variables}, written as $\mathcal{A}$:
    \begin{block}{Types - augmented with type variables}
        \begin{center}
            \begin{tabular}{ r l l }
              $T ::= $ & $T \rightarrow T$ & \emph{function type} \\
               & $\mathcal{A}$ & \emph{type variable} \\
              $\mathcal{A} ::= $ & $\{A,B,\ldots,X_{i \in \mathbb{N}},
                \ldots \}$ & \emph{type variables} \\
            \end{tabular}
        \end{center}
    \end{block}
    \pause
    Let $X \in \mathcal{A}$:
    \begin{itemize}
        \item there's no typing rule that uses the category $\mathcal{A}$
        \item $X$ can represent a \emph{basic} type
            (ie. \texttt{Bool}, \texttt{Nat}, \ldots) or another 
            unspecified type
        \item $X$, being a type, can be used by the defined typing rules
        \item $X \not = Y, \forall Y \in \mathcal{A} \setminus \{X\}$, 
            in other words, $\mathcal{A}$ is infinite and types represented
            by different type variables are different too
    \end{itemize}
    \pause
    \begin{example}
        \begin{displaymath}
            \begin{split}
                \Gamma &\vdash \lambda x:X.x : X \rightarrow X\\
                \Gamma &\vdash \lambda x:A.x : A \rightarrow A\\
                \Gamma &\vdash \lambda s:S. \lambda z: Z. (s\, (s\, z)) : 
                    (Z \rightarrow Z) \rightarrow Z \rightarrow Z\\
            \end{split}
        \end{displaymath}
    \end{example}
\end{frame}

\begin{frame}{Substitutions}
    \begin{center}
        ``I'd like that type variable $X$ in my term $t$ to stands for 
        \texttt{Nat} type. \\Is it possible to do a \emph{substitution}?''
    \end{center}

    \pause
    \begin{block}{Definition of substitution}
        A \emph{type substitution} $\sigma$ is a mapping $\sigma: \mathcal{A}
        \rightarrow T$ \\~\\
        A \emph{substitution application} $\sigma T_{1}$ 
        of a type substitution $\sigma$ to a type $T_{1}$ is defined 
        inductively on the structure of types:
        \begin{displaymath}
            \begin{split}
                X \in \mathcal{A} \wedge \exists T_1: (X \mapsto T_{1}) 
                    \in \sigma & \rightarrow \sigma X = T_{1} \\ 
                X \in \mathcal{A} \wedge \forall T_1: (X \mapsto T_{1}) 
                    \not \in \sigma & \rightarrow \sigma X = X \\ 
                T_{1} \text{ is a concrete type } &\rightarrow  
                    \sigma T_{1} = T_{1}\\
                T_{1}, T_{2} \in T & \rightarrow \sigma(T_{1} \rightarrow 
                    T_{2}) = \sigma T_{1} \rightarrow \sigma T_{2} \\ 
            \end{split}
        \end{displaymath}
    \end{block}
    \pause
    For the following it is useful to introduce two combinations 
    (let $\mathcal{C}$ is a set of contexts):
    \begin{itemize}
        \item $\Gamma = \{ x_1:T_1, \ldots, x_n:T_n\} \in \mathcal{C} 
            \rightarrow \sigma\Gamma = (x_1:\sigma T_1, \ldots,
                x_n:\sigma T_n) \in \mathcal{C}$
        \item let $\sigma, \gamma$ be two type substitutions, their
            composition $\sigma \circ \gamma$ is defined as follows:
            \begin{displaymath}
                \begin{split}
                    \sigma \circ \rho &= \{X \mapsto \sigma T_1 | \,
                        \forall T_1:(X \mapsto T_1) \in \rho \} \cup \\
                    &\quad \{X \mapsto T_1 |\, 
                        \forall T_{1}:\left( (X \mapsto T_1) \in \sigma \wedge
                            (X \mapsto T_1) \not \in \rho\right)\} \\
                \end{split}
            \end{displaymath}
            
    \end{itemize}
\end{frame}

\begin{frame}{Typing relation is closed under substitution application}
    \begin{theorem}
        Let $\sigma$ be a type substitution, $\Gamma$ a context, 
        $T_1 \in T$ and $t$ a term. Then:
        \begin{displaymath}
            \Gamma \vdash t:T_1 \rightarrow \sigma\Gamma \vdash \sigma t: \sigma T_1
        \end{displaymath}
    \end{theorem}
    \begin{proof}
        TODO
    \end{proof}
\end{frame}

\subsection{Parametric polymorphism and type inference}

\begin{frame}{Parametric Polymorphism}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    A first question arises:
    \begin{itemize}
        \item $\forall \sigma. \exists T_1: 
            \sigma \Gamma \vdash \sigma t : T_1$\\
            {\footnotesize Do all type sustitution $\sigma$ makes the term 
                $\sigma t$ typeable under assumption $\sigma \Gamma$?}\\~\\
            If this is the case, why not write \emph{any} concrete type
            using a type variable and use a substitution to obtain the 
            original one? 
            \pause
            \begin{example}
                Write $\lambda s:Z \rightarrow Z.\lambda z:Z.(s\, (s\, z))$
                instead of $\lambda s:Nat \rightarrow Nat.
                    \lambda z:Nat.(s\, (s\, z))$ \\~\\
                For example, if we work with concrete type $String$ just use 
                $\sigma = \{Z \mapsto String\} $
            \end{example}
            \pause
            Holding type variables abstract during type checking is called
            \emph{parametric polymorphism}: type variables are used to allow
            a term in which they appear usable in many concrete contexts
    \end{itemize}
\end{frame}

\begin{frame}{Type inference}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    A second question arises:
    \begin{itemize}
        \item $\exists \sigma. \exists T_1: 
            \sigma \Gamma \vdash \sigma t : T_1$\\
            {\footnotesize Is it always possible to find a type 
                sustitution $\sigma$ such that the term 
                $\sigma t$ is typeable under assumption $\sigma \Gamma$?}\\~\\
            If this is the case, suppose $\not \exists T_{1}.
            \Gamma \vdash t:T_1$, using 
            type substitution $\sigma$ we're able to give a type $T_{2}$ 
            to $\sigma t$, formally $\sigma \Gamma \vdash \sigma t: T_{2}$
            \pause
            \begin{example}
                $\lambda s:S.\lambda z:Z.(s\, (s\, z))$ 
                has {\color{red} no} type, $\forall S,Z \in \mathcal{A}$\\~\\
                but it has type if we use $\sigma = \{
                    S \mapsto Nat \rightarrow Nat, Z \mapsto Nat\}$ or
                    $\sigma = \{S \mapsto Z \rightarrow Z\}$
            \end{example}
            \pause
            Looking for valid ``instantiations'' of type variables is called
            \emph{type inference}: the compiler fill in type information 
            wherever the user don't specify them
    \end{itemize}
\end{frame}

\subsection{Definition of solution for $(\Gamma, t)$}

\begin{frame}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    \begin{block}{Definition of \emph{solution} for $(\Gamma, t)$}
        Let $\sigma$ be a type substitution and $T_{1} \in T$.\\
        A  \emph{solution} for $(\Gamma, t)$ is a pair $(\sigma, T_{1})$
        such that $\sigma \Gamma \vdash \sigma t:T_{1}$
    \end{block}
    \pause
    \begin{example}
        Let $\Gamma = \{f:X, a:Y\}$ and $t = f\, a$ then:
        \begin{displaymath}
            ([X \mapsto Nat \rightarrow Nat, Y \mapsto Nat], Nat) \quad 
            ([X \mapsto Y \rightarrow Z], Z)
        \end{displaymath}
        are both solutions for $(\Gamma, t)$.
    \end{example}
\end{frame}

\section{Constrait-based typing}
\subsection{Constraint set and relations}
\begin{frame}
    Questions:
    \begin{itemize}
        \item During an execution of a type-checking algorithm, why
                    not record constraints of the form $S_i = T_i$ instead 
                    to actually perform a type comparison?
        \item As we've seen in the last example, there exists countable 
                    solutions for a pair $(\Gamma, t)$, are they related in 
                    some way? 
    \end{itemize}
    \pause
    \begin{block}{Definition of \emph{constraint set} 
                    and \emph{unify} relation}
        A \emph{constraint set} $\mathcal{C}$ is a set of equations 
        $\{S_i \triangleq T_i \}_{i \in \mathbb{N}}$ such that 
        $\mathcal{C} \subseteq T \times T$
        \\~\\
        A type substitution $\sigma$ \emph{unify} an equation 
        $S \triangleq T$, written as $\sigma \Join S \triangleq T$, 
        if $\sigma S = \sigma T$
        \\~\\
        Extending the unification relation to constraint sets, a type substitution
        $\sigma$ \emph{unify} a constraint set $\mathcal{C}$, written as 
        $\sigma \Join \mathcal{C}$, if $\forall (S \triangleq T)
        \in \mathcal{C}: \sigma \Join (S \triangleq T)$ 
    \end{block}
    \pause
    Answers:
    \begin{itemize}
        \item The modified type checking algorithm prove that a 
            term $t$ has type $T_1$ under assumptions $\Gamma$ 
            whenever there exists a type substitution $\sigma$ such that 
            $\sigma \Join \mathcal{C}$
        \item let $\mathcal{C}$ be a constraint set for a pair $(\Gamma, t)$.
            Two solutions $(\sigma_1,T_1)$ and $(\sigma_2,T_2)$ are related if  
            $\sigma_1 \Join \mathcal{C}$ and $\sigma_2 \Join \mathcal{C}$ 
    \end{itemize}
\end{frame}


\begin{frame}
    Let's see an example of how we collect a constraint $S \triangleq T$
    \begin{example}
        Suppose to have an application term $t_1 t_2$ with $\Gamma \vdash t_1 : T_1$
        and $\Gamma \vdash t_2 : T_2$ \\~\\
        Instead of checking:
        \begin{itemize}
            \item $T_1$ has the form $T_2 \rightarrow T_{12}$, for some $T_{12}$
            \item $t_1 t_2$ has type \emph{exactly} $T_{12}$
        \end{itemize}
        We suspend a decision for the type $T_{12}$, abstracting it with a 
        \emph{fresh} type variable $X$, creating the constraint 
        $T_1 \triangleq T_2 \rightarrow X$ (hence $t_1 t_2$
        has type $X$ from now on!)
    \end{example}
    \pause
    The following questions drive what follow:
    \begin{itemize}
        \item given a pair $(\Gamma, t)$ there always exist a constraint set?
        \item suppose a constraint set exists, is it unique?
        \item assume the existence is enough, how is its construction defined
                for all cases?
        \item how can we use the constraint set to build a solution for $(\Gamma, t)$?
    \end{itemize}
\end{frame}

\subsection{Constraint typing relation}

\begin{frame}
    \begin{block}{Definition of \emph{constraint typing relation} 
            $\Gamma \vdash t : T_1 \; \textbar_\mathcal{X} \; \mathcal{C}$}
        The \emph{constraint typing relation} where a term $t$ has type
            $T_1$ under assumptions $\Gamma$ 
            whenever exists a type substitution $\sigma$ such that 
            $\sigma \Join \mathcal{C}$, written as
            $\Gamma \vdash t : T_1 \textbar_\mathcal{X} \mathcal{C}$,
            is defined inductively as follow:
            \begin{center}
                \begin{tabular}{ c r }
                        $\displaystyle {{x:T \in \Gamma}\over
                        {\Gamma \vdash x:T \; \textbar_{\emptyset}\;  \emptyset}} $ 
                            & (\emph{CT-VAR}) \\ 
                   & \\
                   $\displaystyle{{\Gamma, x:T_{1} \vdash t_{2}:T_{2}\;
                    \textbar_{\mathcal{X}} \; \mathcal{C} }\over
                        {\Gamma \vdash \lambda x:T_{1}.t_{2} : T_{1} 
                            \rightarrow T_{2}\;
                    \textbar_{\mathcal{X}} \; \mathcal{C} }} $ & (\emph{CT-ABS}) \\
                   & \\ 
                   ${\displaystyle{{{
                        \begin{array}{rl}
                         \text{let} & X \text{ be fresh variable} \\
                        \Gamma \vdash & t_{1}:T_{1} \; \textbar_{\mathcal{X}_1} \;
                            \mathcal{C}_1  \\
                        \Gamma \vdash & t_{2}:T_{2} \; \textbar_{\mathcal{X}_2} \;
                            \mathcal{C}_2  \\
                         \mathcal{C}^{\prime} = & \mathcal{C}_1 \cup \mathcal{C}_2
                            \cup \{ T_1 \triangleq T_2 \rightarrow X \}
                        \end{array}}\over
                        {\Gamma \vdash t_{1} \, t_{2} : X\;
                    \textbar_{\mathcal{X}_1 \cup \mathcal{X}_2 \cup
                        \{X\}} \; \mathcal{C}^{\prime} }}}} $ & (\emph{CT-APP}) \\
                \end{tabular}
            \end{center}
        The set $\mathcal{X}$ is used to track type variables introduced
            by applications of rule \emph{CT-APP}
    \end{block}
\end{frame}

\frame{
\frametitle{Colors}
\footnotesize
\begin{equation*} {{\onslide<2->{\displaystyle
        {   {
                \onslide<3->{ \displaystyle {   {
                    \onslide<4->{\displaystyle {   {
                    \onslide<5->{                    \displaystyle { 
                        {{\onslide<6->{\displaystyle
                                    { {{\onslide<7->{x:S_3 \in \Gamma 
                                        , x : S_3}}\over{                        
                                        \Gamma, x:X\vdash x:S_3 
                                        \,|_{\mathcal{X}_3}\, 
                                        \mathcal{C}_3}}
                                    }
                                \quad
                                    { {{\onslide<7->{3}}\over{                        
                                        \Gamma, y:Y, z:Z\vdash        
                                        (y \, z):S_2 
                                        \,|_{\mathcal{X}_2}\, 
                                        \mathcal{C}_2}}
                                    }
                                 }}\over{                        
                        \Gamma, x:X, z:Z\vdash        (x \, z):S_1 
                        \,|_{\mathcal{X}_1}\, \mathcal{C}_1}}
                        } \quad
                        { 
                            {{\onslide<6->{3}}\over{                        
                            \Gamma, y:Y, z:Z\vdash        
                                (y \, z):S_2 \,|_{\mathcal{X}_2}\, 
                                    \mathcal{C}_2}}
                        }
                    }}
                \over{\Gamma, x:X, y:Y, z:Z\vdash 
                    (x\, z)\, (y \, z):S\,|_{\mathcal{X}}\, \mathcal{C}}}}}
                \over{\Gamma, x:X, y:Y\vdash \lambda z:Z.
                    ((x\, z)\, (y \, z)):S\,|_{\mathcal{X}}\, \mathcal{C}}}}}
            \over{\Gamma, x:X \vdash  \lambda y:Y.\lambda z:Z.
                ((x\, z)\, (y \, z)):S\,|_{\mathcal{X}}\, \mathcal{C}}}} }
    \over{\Gamma \vdash \lambda x:X. \lambda y:Y.\lambda z:Z.
        ((x\, z)\, (y \, z)):S\,|_{\mathcal{X}}\, \mathcal{C}}}
\end{equation*} \normalsize
}

\begin{frame}
\footnotesize
    \begin{center}
        \begin{overprint}
            \onslide<1>
            \begin{tabular}{c}
                {}\\
                {}\\
                $\displaystyle {{}\over{\Gamma \vdash \lambda x:X.  
                \lambda y:Y.\lambda z:Z.  ((x\, z)\, (y \, 
                z)):S_1\,|_{\mathcal{X}}\, \mathcal{C}}}$
            \end{tabular}
            \onslide<2>
                \begin{tabular}{c}
                {}\\
                $\displaystyle {{{}\over{\Gamma, x:X \vdash \lambda 
                    y:Y.\lambda z:Z.  ((x\, z)\, (y \, 
                    z)):S_2\,|_{\mathcal{X}}\, \mathcal{C}}}} $\\
                $\displaystyle {{}
                    \over{\Gamma \vdash \lambda x:X. \lambda y:Y.\lambda z:Z.
                    ((x\, z)\, (y \, z)):X \rightarrow S_2
                \,|_{\mathcal{X}}\, \mathcal{C}}}$
                \end{tabular}
            \onslide<3>
                \begin{tabular}{c}
                $\displaystyle {{{}\over{\Gamma, x:X, y:Y \vdash 
                    \lambda z:Z.  ((x\, z)\, (y \, 
                    z)):S_3\,|_{\mathcal{X}}\, \mathcal{C}}}} $\\
                $\displaystyle {{{}\over{\Gamma, x:X \vdash \lambda 
                    y:Y.\lambda z:Z.  ((x\, z)\, (y \, z)):Y 
                    \rightarrow S_3\,|_{\mathcal{X}}\, \mathcal{C}}}} 
                    $\\
                $\displaystyle {{}
                    \over{\Gamma \vdash \lambda x:X. \lambda y:Y.\lambda z:Z.
                    ((x\, z)\, (y \, z)):X \rightarrow Y \rightarrow 
                S_3\,|_{\mathcal{X}}\, \mathcal{C}}}$
                \end{tabular}
            \onslide<4>
                \begin{tabular}{c}
                    $\displaystyle {{{}\over{\Gamma, x:X, y:Y, z:Z 
                    \vdash
                    (x\, z)\, (y \, z):S_4\,|_{\mathcal{X}}\, 
                    \mathcal{C}}}} $\\
                    $\displaystyle {{{}\over{\Gamma, x:X, y:Y \vdash 
                        \lambda z:Z.  ((x\, z)\, (y \, 
                        z)):Z\rightarrow S_4\,|_{\mathcal{X}}\, 
                        \mathcal{C}}}} $\\
                    $\displaystyle {{{}\over{\Gamma, x:X \vdash \lambda 
                        y:Y.\lambda z:Z.  ((x\, z)\, (y \, z)):Y 
                        \rightarrow Z \rightarrow 
                        S_4\,|_{\mathcal{X}}\, \mathcal{C}}}} $\\
                    $\displaystyle {{}
                        \over{\Gamma \vdash \lambda x:X. \lambda y:Y.\lambda z:Z.
                        ((x\, z)\, (y \, z)):X \rightarrow Y 
                    \rightarrow Z\rightarrow S_4\,|_{\mathcal{X}}\, 
                    \mathcal{C}}}$
                \end{tabular}
            \onslide<5>
                \begin{tabular}{c}
                    \begin{tabular}{lr}
                        \begin{tabular}{c}
                            $\displaystyle {{{}\over{\Gamma, x:X, z:Z 
                            \vdash
                            x\, z:S_1\,|_{\mathcal{X}_1}\, 
                            \mathcal{C}_1}}} $                        
                            \end{tabular}&
                        \begin{tabular}{c}
                            $\displaystyle {{{}\over{\Gamma, y:Y, z:Z 
                            \vdash
                            y \, z:S_2\,|_{\mathcal{X}_2}\, 
                            \mathcal{C}_2}}} $                        
                            \end{tabular}
                    \end{tabular}\\
                $\displaystyle {{{}\over{\Gamma, x:X, y:Y, z:Z \vdash
                (x\, z)\, (y \, 
                z):A\,|_{\mathcal{X}_1\cup\mathcal{X}_2\cup\{A\}}\, 
                \mathcal{C}_{1}\cup\mathcal{C}_{2}\cup\{S_1=S_2\rightarrow 
                A\}}}} $\\
                $\displaystyle {{{}\over{\Gamma, x:X, y:Y \vdash 
                    \lambda z:Z.  ((x\, z)\, (y \, z)):Z \rightarrow A 
                    \,|_{\mathcal{X}_1\cup\mathcal{X}_2\cup\{A\}}\, 
                    \mathcal{C}_{1}\cup\mathcal{C}_{2}\cup\{S_1=S_2\rightarrow 
                    A\}}}} $\\
                $\displaystyle {{{}\over{\Gamma, x:X \vdash \lambda 
                    y:Y.\lambda z:Z.  ((x\, z)\, (y \, z)):Y 
                    \rightarrow Z\rightarrow A\,|_{\mathcal{X}_1
                    \cup\mathcal{X}_2\cup\{A\}}\, 
                \mathcal{C}_{1}\cup\mathcal{C}_{2}\cup\{S_1=S_2\rightarrow 
                A\}}}}  $\\
                $\displaystyle {{}
                    \over{\Gamma \vdash \lambda x:X. \lambda y:Y.\lambda z:Z.
                    ((x\, z)\, (y \, z)):X \rightarrow Y \rightarrow 
                Z\rightarrow 
                A\,|_{\mathcal{X}_1\cup\mathcal{X}_2\cup\{A\}}\, 
                \mathcal{C}_{1}\cup\mathcal{C}_{2}\cup\{S_1=S_2\rightarrow 
                A\}}} $
                \end{tabular}
            \onslide<6>
                \begin{tabular}{c}
                    \begin{tabular}{lr}
                        \begin{tabular}{c}
                            \begin{tabular}{lr}
                                \begin{tabular}{c}
                                    $\displaystyle {{{}\over{\Gamma, 
                                    x:X \vdash x :S_3\,|_{\mathcal{X}_3}\, 
                                    \mathcal{C}_3}}} $
                                \end{tabular} &
                                \begin{tabular}{c}
                                    $\displaystyle {{{}\over{\Gamma, 
                                    z:Z \vdash z 
                                    :S_4\,|_{\mathcal{X}_4}\, 
                                    \mathcal{C}_4}}} $
                                \end{tabular}
                            \end{tabular}\\
                            $\displaystyle {{{}\over{\Gamma, x:X, z:Z 
                            \vdash
                            x\, 
                            z:B\,|_{\mathcal{X}_3\cup\mathcal{X}_4
                            \cup{\{B\}}}\, 
                            \mathcal{C}_3\cup\mathcal{C}_4\cup\{S_3 = 
                            S_4 \rightarrow B\}}}} $
                            \end{tabular}&
                            %put in the following tabular the previous 
                            %changes about nested tabular
                        \begin{tabular}{c}
                            $\displaystyle {{{}\over{\Gamma, y:Y, z:Z 
                            \vdash
                            y \, z:S_2\,|_{\mathcal{X}_2}\, 
                            \mathcal{C}_2}}} $                        
                            \end{tabular}
                    \end{tabular}\\
                $\displaystyle {{{}\over{\Gamma, x:X, y:Y, z:Z \vdash
                (x\, z)\, (y \, 
                z):A\,|_{\mathcal{X}_3\cup\mathcal{X}_4\cup\mathcal{X}_2
                    \cup\{A,B\}}\, 
                \mathcal{C}_{3}\cup\mathcal{C}_{4}\cup\mathcal{C}_{2}\cup\{B=S_2\rightarrow 
                A, S_3 = S_4 \rightarrow B\}}}} $\\
                $\displaystyle {{{}\over{\Gamma, x:X, y:Y \vdash 
                    \lambda z:Z.  ((x\, z)\, (y \, z)):Z \rightarrow A 
                    \,|_{\mathcal{X}_3\cup\mathcal{X}_4\cup\mathcal{X}_2
                        \cup\{A,B\}}\, 
                    \mathcal{C}_{3}\cup\mathcal{C}_{4}\cup\mathcal{C}_{2}\cup\{B=S_2\rightarrow 
                    A, S_3 = S_4 \rightarrow B\}}}} $\\
                $\displaystyle {{{}\over{\Gamma, x:X \vdash \lambda 
                    y:Y.\lambda z:Z.  ((x\, z)\, (y \, z)):Y 
                    \rightarrow Z\rightarrow 
                    A\,|_{\mathcal{X}_3\cup\mathcal{X}_4
                    \cup\mathcal{X}_2\cup\{A,B\}}\, 
                \mathcal{C}_{3}\cup\mathcal{C}_{4}\cup\mathcal{C}_{2}\cup\{B=S_2\rightarrow 
                A, S_3 = S_4 \rightarrow B\}}}}  $\\
                $\displaystyle {{}
                    \over{\Gamma \vdash \lambda x:X. \lambda y:Y.\lambda z:Z.
                    ((x\, z)\, (y \, z)):X \rightarrow Y \rightarrow 
                Z\rightarrow 
                A\,|_{\mathcal{X}_3\cup\mathcal{X}_4\cup\mathcal{X}_2
                    \cup\{A,B\}}\, 
                \mathcal{C}_{3}\cup\mathcal{C}_{4}\cup\mathcal{C}_{2}\cup\{B=S_2\rightarrow 
                A, S_3 = S_4 \rightarrow B\}}} $
                \end{tabular}
        \end{overprint}
    \end{center}
    \normalsize
\end{frame}

\subsection{Definition of solution for $(\Gamma, t, S, \mathcal{C})$}

\begin{frame}
    It is helpful make the following observations:
    \begin{itemize}
        \item when a type variable $X$ is choosen by a final rule which has
            some premises, then $X$ is different from all other type variables
            introduced by premises' subderivations
        \item for any given pair $(\Gamma, t)$ the rules provide a procedure to 
            build sets $\mathcal{X}, \mathcal{C}$ and find type $T_1$ such that
            $\Gamma \vdash t : T_1 \; \textbar_\mathcal{X} \; \mathcal{C}$
        \item if we consider the relation  
            $\Gamma \vdash t : T_1 \; \textbar_\mathcal{X} \; \mathcal{C}$ modulo
            the choice of fresh variables, then the constraint set $\mathcal{C}$ and
            type $T_1$ are \emph{uniquely} determined
        \item in order to find solutions for $(\Gamma, t)$ we use the given rules to:
            \begin{enumerate}
                \item build the constraint set $\mathcal{C}$, that
                    must be satisfied in order for $t$ to have a type
                \item determine a type $S$ possibly containing type variables (which are 
                    subjects under constraints in $\mathcal{C}$), which caracterizes
                    the types of $t$ in terms of these variables
                \item find a type sustitution $\sigma$ such that $\sigma \Join 
                    \mathcal{C}$: for each such $\sigma$ the type $\sigma S$ is
                    a possible type for $t$, hence $(\sigma, \sigma S)$ 
                    is a solution for $(\Gamma, t)$
                \item if no type sustitution $\sigma \Join \mathcal{C}$ exists then
                    there is no way to instantiate type variables in $t$ in order
                    for $t$ to have a type.
            \end{enumerate}
    \end{itemize}
\end{frame}


\begin{frame}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    \begin{block}{Definition of \emph{solution} for $(\Gamma, t, S, \mathcal{C})$}
        Let $\sigma$ be a type substitution and $T_{1} \in T$ and suppose
            $\Gamma \vdash t : T_1 \; \textbar_\mathcal{X} \; \mathcal{C}$ \\
        A  \emph{solution} for $(\Gamma, t, S, \mathcal{C})$ is a pair 
        $(\sigma, T_{1})$ such that $\sigma \Join \mathcal{C} \wedge \sigma S = T_1$
    \end{block}
    \pause
    \begin{example}
        Let $t = \lambda x:X\rightarrow Y. x \, 0$ then:
        \begin{displaymath}
            \begin{split}
                S &= (X \rightarrow Y) \rightarrow Z \\
                \mathcal{C} &= \{Nat \rightarrow Z \triangleq X \rightarrow Y\}\\
                \sigma &= \{X \mapsto Nat, Z \mapsto Bool, Y \mapsto Bool\}\\
            \end{split}
        \end{displaymath}
        hence $(\sigma, (Nat \rightarrow Bool) \rightarrow Bool)$ is a solution 
        for $(\Gamma, t, S, \mathcal{C})$.
    \end{example}
\end{frame}
\subsection{Soundness and Completeness of Constraint typing}
\begin{frame}
    Let $\Gamma$ be a context and $t$ be a term containing free variables\\~\\
    We have two different ways of instantiating type variables appearing in $t$
    to produce a typeable term. In the next definitions $\sigma$ is a type
    sustitution and $T_1 \in T$ as usual:
    \begin{block}{Declarative approach}
        $\Omega = \{ \omega = (\sigma, T_1): \omega\text{ is solution of } (\Gamma, t)\}$
    \end{block}

    \begin{block}{Algorithmic approach}
        $\Theta = \{ \theta = (\sigma, T_1): \theta\text{ is solution of } 
            (\Gamma, t, S, \mathcal{C})\}$
    \end{block}
    
    \pause

    \begin{theorem}
    $\Omega = \Theta$    
    \end{theorem}
\end{frame}

\begin{frame}
    \footnotesize
    \begin{proof}[Proof. Soundness of Constraint typing. We show that: 
        $\Omega \supseteq \Theta$]
        By hypothesis, let $\Gamma \vdash t : S \, |_{\mathcal{X}} \,
        \mathcal{C}$ ($\mathcal{X}$ is useless in this proof) and 
        $(\sigma, T_1)$ a solution for $(\Gamma, t, S, \mathcal{C})$.  
        Proceed by induction on the last constraint type relation rule 
        applied:
        \begin{description}
            \item[CT-VAR] ${{x:S\in\Gamma}\over{\Gamma \vdash x:S
                \,|\,\emptyset}}$ is the applied
                rule.  By typing rule \emph{T-VAR} follows $x:S\in 
                \Gamma \rightarrow \Gamma \vdash x:S$. Since typing is 
                preserved under type substitution, $\sigma\Gamma 
                \vdash \sigma x:\sigma S$.  But $(\sigma, T_1)$ is 
                solution for $(\Gamma, x, S, \emptyset)$ by theorem 
                hp, hence $\sigma S = T_1$ getting $\sigma \Gamma 
                \vdash \sigma x:T_1$, so $(\sigma, T_1)$ is solution 
                for $(\Gamma, x)$  which is like to say $(\sigma, 
                T_1)\in\Omega$ as required.
            \item[CT-ABS] ${{\Gamma, x:S_1\vdash t_2: S_2 
                \,|\,\mathcal{C}}\over{\Gamma \vdash x:S_1.t_2:S_1 
                \rightarrow S_2 \,|\,\mathcal{C}}}$ is the applied 
                rule.  By premises, let $(\sigma, \sigma S_2)$ be 
                solution for $(x:S_1 \cup \Gamma, t_2, S_2, 
                \mathcal{C})$ so we apply induction hp, having 
                $(\sigma, \sigma S_2) \in \Omega$, in other
                words $(\sigma, \sigma S_2)$ is solution for $(x:S_1 
                \cup \Gamma, t_2)$, so we write $\sigma\Gamma,x:\sigma 
                S_1 \vdash \sigma t_2 : \sigma S_2$ which is the 
                premise of \emph{T-ABS} rule, hence $\sigma \Gamma 
                \vdash \lambda x:\sigma S_1.\sigma t_2: \sigma S_1 
                \rightarrow \sigma S_2$
                . But $(\sigma, T_1)$ is solution for
                $(\Gamma, \lambda x:S_1.t_2, S_1\rightarrow S_2, 
                \mathcal{C})$ by theorem hp, hence $\sigma \Join 
                \mathcal{C} \wedge \sigma (S_1 \rightarrow S_2) = 
                T_1$. By def of substitution application $\sigma (S_1 
                \rightarrow \sigma S_2) = \sigma S_1 \rightarrow S_2$, 
                hence
                we can rewrite $\sigma \Gamma \vdash \lambda x:\sigma 
                S_1.\sigma t_2:T_1$, so $(\sigma, T_1)$ is solution 
                for $(\Gamma, \lambda x:S_1.t_2)$  which is like to 
                say $(\sigma, T_1) \in \Omega$ as required.  

            \item[CT-APP] ${{
                        \begin{array}{rl}
                          \Gamma \vdash t_{1}:S_{1} \; \textbar \;
                            \mathcal{C}_1  &
                        \Gamma \vdash  t_{2}:S_{2} \; \textbar \;
                            \mathcal{C}_2  \\
                         \mathcal{C}^{\prime} = \mathcal{C}_1 \cup 
                            \mathcal{C}_2
                            \cup & \{ S_1 \triangleq S_2 \rightarrow X 
                        \} \end{array}}\over
                        {\Gamma \vdash t_{1} \, t_{2} : X\;
                    \textbar_{\mathcal{X}_1 \cup \mathcal{X}_2 \cup
                        \{X\}} \; \mathcal{C}^{\prime} }}$ is the 
                        applied rule. By induction hp, we have both 
                        $(\sigma, \sigma S_1)$ is solution for 
                        $(\Gamma, t_1)$ both $(\sigma, \sigma S_2)$ is 
                        solution for $(\Gamma, t_2)$, in other words 
                        $\sigma \Gamma \vdash \sigma t_1 : \sigma S_1$ 
                        and $\sigma \Gamma \vdash \sigma t_2 : \sigma 
                        S_2$. By theorem hp, $(\sigma,T_1)$ is 
                        solution for $(\Gamma, t_1 t_2, X, 
                        \mathcal{C}^{\prime})$, hence $\sigma \Join 
                        \mathcal{C}^{\prime}$, in particular $\sigma 
                        \Join S_1\triangleq S_2\rightarrow X$, which 
                        does mean $\sigma S_1 = \sigma S_2 \rightarrow 
                        \sigma X$. Substituting $\sigma S_1$ in the 
                        previous $\sigma \Gamma \vdash \sigma t_1 : 
                        \sigma S_1$ we have the two premises to apply 
                        \emph{T-APP} rule, from $\sigma\Gamma \vdash
                        \sigma t_1:\sigma S_2 \rightarrow \sigma X$ 
                        and $\sigma \Gamma \vdash \sigma t_2 :\sigma 
                        S_2$ follows that $\sigma \Gamma \vdash 
                        (\sigma t_1) (\sigma t_2) : \sigma X$. Again, 
                        $(\sigma,T_1)$ is solution for $(\Gamma, t_1 
                        t_2, X, \mathcal{C}^{\prime})$, hence $\sigma 
                        X = T_1$, we have $\sigma \Gamma \vdash 
                        (\sigma t_1) (\sigma t_2) : T_1$, so $(\sigma, 
                        T_1)$ is solution for $(\Gamma, t_1 \, t_2)$
                        which is like to say $(\sigma, T_1)\in\Omega$ 
                        as required.
                
        \end{description}
    \end{proof}
    \normalsize
\end{frame}

\begin{frame}
    \begin{proof}[Proof. Completeness of Constraint typing]
    \end{proof}
\end{frame}

\section{Unification}
\subsection{Algorithm}
\begin{frame}
    \begin{block}{Unification algorithm}
        By pattern matching on the structure of constraint set $\mathcal{C}$
        given as argument:
        \begin{displaymath}
            \begin{split}
                unify(\emptyset) &= [\,] \\
                unify(\{T_1 \triangleq T_2\} \cup \mathcal{C}^{\prime}) &=
                    unify(\mathcal{C}^{\prime})
                    \quad \text{if } T_1 = T_2\\
                unify(\{X \triangleq T_1\} \cup \mathcal{C}^{\prime}) &=
                    unify([ X \mapsto T_1]\mathcal{C}^{\prime}) \circ [X \mapsto T_1]
                    \quad \text{if } X \not \in FV(T_1)\\
                unify(\{T_1 \triangleq X\} \cup \mathcal{C}^{\prime}) &=
                    unify([ X \mapsto T_1]\mathcal{C}^{\prime}) \circ [X \mapsto T_1]
                    \quad \text{if } X \not \in FV(T_1)\\
                unify(\{T_1 \rightarrow T_2 \triangleq S_1\rightarrow S_2 \} 
                    \cup \mathcal{C}^{\prime}) &=
                    unify(\mathcal{C}^{\prime} \cup \{T_1 \triangleq S_1,
                        T_2 \triangleq S_2\}) \\
                unify(\_) &= \text{\color{red} raise failure}\\
            \end{split}
        \end{displaymath}
    \end{block}
    \pause
    For the properties' discussion are useful the following concepts:
    \begin{itemize}
        \item   A type substitution $\sigma$ is \emph{less specific} (or 
                \emph{more general}) than a type substitution $\rho$, written
                as $\sigma \sqsubseteq \rho$, if $\rho = \gamma \circ \sigma$,
                for some type substitution $\gamma$
        \item   A \emph{principal unifier} for a constraint set $\mathcal{C}$ 
                is a type substitution $\sigma$ such that $\sigma \Join \mathcal{C}$
                and $\forall \rho \Join \mathcal{C}: \sigma \sqsubseteq \rho$
    \end{itemize}
    \begin{example}
        Let $\rho = \{S \mapsto Nat \rightarrow Nat, Z \mapsto Nat\}$ 
        and $\sigma = \{S \mapsto Z \rightarrow Z\}$. We have $\sigma 
        \sqsubseteq \rho$ because $\exists \gamma = \{Z \mapsto Nat\}$ 
        such that $\rho = \gamma \circ \sigma$
    \end{example}
\end{frame}

\subsection{Properties}

\begin{frame}
    \begin{theorem}
        $unify(\mathcal{C})$ halts, either by failing or by returning a type 
        substitution $\sigma$
    \end{theorem}
    \footnotesize
    Call \emph{degree} of a constraint set $\mathcal{C}$ a pair $(m,n)$ where
    $m$ is the number of distinct type variables and $n$ is the number of
    distinct types in $\mathcal{C}$
    \begin{proof}[Proof. By complete induction on the degree of $\mathcal{C}$]
    \textbf{Base} $(0,0) \equiv \mathcal{C} = \emptyset$, 
        $unify(\emptyset) = [\,]$ applies, which returns the empty substitution\\
    \textbf{Induction HP} assume the theorem holds 
        $\forall (s,t): (s,t) < (m,n)$ \\
    \textbf{Induction Step} proceed by pattern matching on the 
        structure of $\mathcal{C}$: 
        \begin{itemize}
            \item $unify(\{T_1 \triangleq T_2\} \cup \mathcal{C}^{\prime})
                    \quad \text{if } T_1 = T_2$ does what 
                    $unify(\mathcal{C}^{\prime})$ does, but $\mathcal{C}^{\prime}$ 
                    has a type less, so
                    has a smaller degree than $\{T_1 \triangleq T_2\} \cup 
                    \mathcal{C}^{\prime}$, hence induction hp applies 
            \item $unify(\{X \triangleq T_1\} \cup \mathcal{C}^{\prime})$ compose
            what $unify([ X \mapsto T_1]\mathcal{C}^{\prime})$ returns 
            with $[X \mapsto T_1]$ , but 
            $[ X \mapsto T_1]\mathcal{C}^{\prime}$ has a variable less, 
            so has a smaller degree than $\{X \triangleq T_1\} \cup \mathcal{C}^{\prime}$,
            hence induction hp applies and composition always halt
            \item $unify(\{T_1 \rightarrow T_2 \triangleq S_1\rightarrow S_2 \} 
                    \cup \mathcal{C}^{\prime})$ does what
                    $unify(\mathcal{C}^{\prime} \cup \{T_1 \triangleq S_1,
                        T_2 \triangleq S_2\})$ does, but 
                        $\mathcal{C}^{\prime} \cup \{T_1 \triangleq S_1,
                            T_2 \triangleq S_2\}$ has two arrow types less,
                        so has a smaller degree than 
                        $\{T_1 \rightarrow T_2 \triangleq S_1\rightarrow S_2 \} 
                            \cup \mathcal{C}^{\prime}$, hence induction hp applies
            \item if $\mathcal{C}$ has a different structure from the above ones, 
                $unify(\mathcal{C})$ fails to return a type substitution
        \end{itemize}
        All structures of $\mathcal{C}$ have been covered, hence $unify(\mathcal{C})$
        either produces a type substitution $\sigma$ or fails to do so, this complete
        the induction.
    \end{proof}
    \normalsize
\end{frame}

\begin{frame}
    \begin{theorem}
        $unify(\mathcal{C}) = \sigma \rightarrow \sigma \Join \mathcal{C}$
    \end{theorem}
    \footnotesize
    \begin{proof}[Proof. By structural induction on $\mathcal{C}$]
    \textbf{Base} $\mathcal{C} = \emptyset$, 
        $unify(\emptyset) = [\,]$ applies, 
        $\forall\sigma: \sigma \Join \emptyset$ (no equation needs 
        to be unified)\\
    \textbf{Induction HP} assume the theorem holds for a generic
        $\mathcal{C}^{\prime}$ and prove for a new set 
        $\{T_1 \triangleq T_2\} \cup \mathcal{C}^{\prime}$
        where $T_1,T_2 \in T$ (possibly containing type variables) \\
    \textbf{Induction Step} proceed by pattern matching on the 
        structure of the new set $\{T_1 \triangleq T_2\} \cup 
        \mathcal{C}^{\prime}$: 
        \begin{itemize}
            \item $unify(\{T_1 \triangleq T_2\} \cup \mathcal{C}^{\prime})
                \quad \text{if } T_1 = T_2$ does what 
                $unify(\mathcal{C}^{\prime})$ does: by induction hp 
                $unify(\mathcal{C}^{\prime}) = \sigma \rightarrow
                \sigma \Join \mathcal{C}^{\prime}$, but the added equation
                is already an identity, hence $\sigma \Join 
                \{T_1 \triangleq T_2\} \cup \mathcal{C}^{\prime}$ 
                if $ T_1 = T_2$

            \item Let $X \in \mathcal{A}$: $unify(\{X \triangleq T_1\}
            \cup \mathcal{C}^{\prime})$
            compose what $unify([ X \mapsto T_1]\mathcal{C}^{\prime})$ 
            returns with $[X \mapsto T_1]$: by induction hp, 
            $unify([ X \mapsto T_1]\mathcal{C}^{\prime}) = \sigma
            \rightarrow \sigma \Join [ X \mapsto T_1]\mathcal{C}^{\prime}$
            , hence the composition $\rho$, defined as 
            $\sigma \circ [ X \mapsto T_1]$, is such that $\rho \Join
            \{X \triangleq T_1\} \cup \mathcal{C}^{\prime}$

            \item $unify(\{T_1 \rightarrow T_2 \triangleq 
                S_1\rightarrow S_2 \} \cup \mathcal{C}^{\prime})$ 
                does what
                $unify(\mathcal{C}^{\prime} \cup \{T_1 \triangleq S_1,
                    T_2 \triangleq S_2\})$ does: by induction hp 
                    $unify(\mathcal{C}^{\prime} \cup \{T_1 \triangleq S_1,
                    T_2 \triangleq S_2\}) = \sigma \rightarrow 
                    \sigma \Join
                    \mathcal{C}^{\prime} \cup \{T_1 \triangleq S_1,
                    T_2 \triangleq S_2\}$. To unify $T_1 \rightarrow 
                    T_2 \triangleq S_1\rightarrow S_2 $ use def of 
                    substitution application: $\sigma 
                    (T_1 \rightarrow T_2 ) = \sigma T_1 \rightarrow 
                    \sigma T_2$ and  $\sigma 
                    (S_1 \rightarrow S_2 ) = \sigma S_1 \rightarrow 
                    \sigma S_2$. Since $\sigma \Join
                    \mathcal{C}^{\prime} \cup \{T_1 \triangleq S_1,
                    T_2 \triangleq S_2\}$ the arrow types 
                    $\sigma T_1 \rightarrow \sigma T_2$ and
                    $\sigma S_1 \rightarrow \sigma S_2$ are really the
                    same, hence
                    $\sigma \Join \{T_1 \rightarrow T_2 \triangleq 
                    S_1\rightarrow S_2 \} \cup \mathcal{C}^{\prime}$
                    
                    \item if $\{T_1 \triangleq T_2\} \cup \mathcal{C}
                        ^{\prime}$ has a different structure 
                        from the above ones, 
                        $unify(\{T_1 \triangleq T_2\} \cup \mathcal{C}
                        ^{\prime})$ fails to return a type substitution,
                        hence the theorem is vacaously true by
                        ``ex falso quod libet''
        \end{itemize}
        All structures of $\mathcal{C}$ have been covered, hence 
        $unify(\mathcal{C})=\sigma \rightarrow \sigma \Join \mathcal{C}$,
        this complete the induction.
    \end{proof}
    \normalsize
\end{frame}

\begin{frame}
    \begin{theorem}
        $\rho \Join \mathcal{C} \rightarrow unify(\mathcal{C}) = \sigma \wedge 
            \sigma \sqsubseteq \rho$
    \end{theorem}
    \footnotesize
    \begin{proof}[Proof. By structural induction on $\mathcal{C}$]
    \textbf{Base} $\mathcal{C} = \emptyset$, 
        Get any $\rho$ such that $\rho \Join \emptyset$:
        $unify(\emptyset) = [\,]$ applies, since 
        $\forall\gamma: \gamma = \gamma \circ [\,]$, 
        $[\,] \sqsubseteq \rho$ holds as required\\
    \textbf{Induction HP} assume the theorem holds for a generic
        $\mathcal{C}^{\prime}$ and prove for a new set 
        $\{T_1 \triangleq T_2\} \cup \mathcal{C}^{\prime}$
        where $T_1,T_2 \in T$ (possibly containing type variables) \\
    \textbf{Induction Step} proceed by pattern matching on the 
        structure of the new set $\{T_1 \triangleq T_2\} \cup 
        \mathcal{C}^{\prime}$: 
        \begin{itemize}
            \item $unify(\{T_1 \triangleq T_2\} \cup 
                \mathcal{C}^{\prime})
                \quad \text{if } T_1 = T_2$ does what 
                $unify(\mathcal{C}^{\prime})$ does: let $\rho \Join
                \{T_1 \triangleq T_2\} \cup 
                \mathcal{C}^{\prime}$, hence $\rho \Join
                \mathcal{C}^{\prime}$. By induction hp 
                $\rho \Join \mathcal{C}^{\prime} \rightarrow
                unify(\mathcal{C}^{\prime}) = \sigma \wedge
                \sigma \sqsubseteq \rho$, but the added equation
                is already an identity, hence $\sigma \Join 
                \{T_1 \triangleq T_2\} \cup \mathcal{C}^{\prime}$ 
                if $ T_1 = T_2$ and $\sigma \sqsubseteq \rho$

            \item Let $X \in \mathcal{A}$: $unify(\{X \triangleq T_1\}
            \cup \mathcal{C}^{\prime})$
            compose what $unify([ X \mapsto T_1]\mathcal{C}^{\prime})$ 
            returns with $[X \mapsto T_1]$: let $\rho \Join
                \{X \triangleq T_1\} \cup 
                \mathcal{C}^{\prime}$, since $\rho X = \rho T_1$ 
                and $\rho \Join \mathcal{C}^{\prime}$, follows that
                $\rho \Join [X \mapsto T_1]\mathcal{C}^{\prime}$. 
                By induction hp, 
            $unify([ X \mapsto T_1]\mathcal{C}^{\prime}) = \sigma
            \wedge \sigma \sqsubseteq \rho$ and by def of 
            $\sqsubseteq$, holds $\rho = \gamma \circ \sigma$ for a
            $\gamma$. By rule application, $unify(\{X \triangleq T_1\}
            \cup \mathcal{C}^{\prime}) = \sigma \circ [X\mapsto T_1]$,
            so remain to prove $\sigma \circ [X\mapsto T_1] 
            \sqsubseteq \rho$, by def of 
            $\sqsubseteq$, $\rho = \gamma \circ (\sigma \circ
            [X\mapsto T_1])$ for a $\gamma$.
            Consider any $Y\in \mathcal{A}$: if $Y\not = X$ then 
            $(\gamma \circ (\sigma \circ [X\mapsto T_1]))Y = 
            (\gamma \circ \sigma) Y$ which holds by induction hp.
            Otherwise, if $Y=X$ then $(\gamma \circ (\sigma 
            \circ [X\mapsto T_1]))Y = (\gamma \circ \sigma)T_1$
            which holds because $\rho \Join {X\triangleq T_1}$
            \item observe that $\rho \Join \{T_1 \rightarrow T_2 
                \triangleq S_1\rightarrow S_2 \} \cup 
                \mathcal{C}^{\prime})$ if and only if 
                $\rho \Join \{T_1 \triangleq S_1,
                    T_2 \triangleq S_2\}\cup\mathcal{C}^{\prime}$:
                    hence we apply the argument recursively on 
                    $\{T_1 \triangleq S_1,
                    T_2 \triangleq S_2\}\cup\mathcal{C}^{\prime}$
                    
                    \item if $\{T_1 \triangleq T_2\} \cup \mathcal{C}
                        ^{\prime}$ has a different structure 
                        from the above ones, it can only left two cases
                        such that $\not \exists \rho: \rho \Join \mathcal{C}$: 
                        $T_1$ is a concrete type and $T_2$ is an arrow 
                        type (really ``incompossible''), or let $X\in\mathcal{A}$
                        in $T_1=X$ and $X$ appears in $T_2$ (by absurd:  
                        assume $\rho X = \rho T_2$, but $\rho T_2$ is strictly
                        larger that $\rho X$ by choice of $T_2$).
        \end{itemize}
    \end{proof}
    \normalsize
\end{frame}

\subsection{Definition of principal solution for $(\Gamma, t,S, \mathcal{C})$}

\begin{frame}
    Let $\Gamma$ be a context and $t$ be a term containing free variables.
    \begin{block}{Definition of \emph{principal solution} for 
            $(\Gamma, t, S, \mathcal{C})$}
        A  \emph{principal solution} for $(\Gamma, t, S, \mathcal{C})$ 
        is a solution $(\sigma, T_{1})$ such that for any other solution
        $(\rho, T_2)$ for $(\Gamma, t, S, \mathcal{C})$ we have $\sigma 
        \sqsubseteq \rho$.
    \end{block}
    \pause
    \begin{theorem}
        if $(\Gamma, t, S, \mathcal{C})$ has a solution, then it has a 
        principal one too. The unification algorithm can be used to
        decide if $(\Gamma, t, S, \mathcal{C})$ has solutions and if it 
        is the case, it compute the principal one.
    \end{theorem}
\end{frame}

\section{Limitations, worst-cases and complexity}

\section{Interpreter}

\subsection{Lambda calculus grammar}

\begin{frame}{Grammar}
  \begin{block}{Definizione}
    The set T of terms representing the lambda calculus language is the
    smallest set generated by the following rules:
  \begin{displaymath}
    \begin{split}
      \text{Term} &\triangleq \text{AppTerm | ``lambda'' ID ``:'' Type ``.''
        ATerm}\\
      \text{AppTerm} &\triangleq \text{ATerm ATerm} \\
      \text{ATerm} &\triangleq \text{``('' Term ``)'' | ID}\\
      \text{Type} &\triangleq \text{ArrowType}\\
      \text{AType} &\triangleq \text{``('' Type ``)'' | ``Bool'' |
        ``Nat'' | ID}\\
      \text{ArrowType} &\triangleq \text{AType} (\rightarrow
      \text{ArrowType} | \text{AType})\\
    \end{split}
  \end{displaymath}
\end{block}
where:
\begin{itemize}
    \item $\Sigma$ is our alphabet;
    \item ID $\in \Sigma \setminus \{ \text{``lambda'', ``:'', ``.'',
  ``('', ``)'', ``Bool'', ``Nat''} \}$.
\end{itemize}

%\begin{center}
%  \includegraphics[scale=0.4]{images/graph-with-b-setted.eps}
%  \includegraphics[scale=0.4]{images/story-example.eps} 
%  \includegraphics[scale=0.4]{images/non-story-example.eps}
%\end{center} 
\end{frame}

\begin{frame}{Some observations}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
    We make the following observations:
      \begin{itemize}
        \item we design the grammar to be processed by \emph{ANTLR}, a $LL(k)$
            top-down parser;
        \item the grammar seen during lectures has left recursion on 
            $T-APP$ rule (good for LR bottom-up parser);
        \item our grammar maybe ``naive'' in the sense that allow to write 
            some strange terms (ie: \texttt{x (lambda y:Y. x)}) but for our 
            scope is enough;
        \item it allows to write some ``obscure'' terms (ie: 
            \texttt{lambda x:X.(x x)}) which we desire to prove not safe.
    \end{itemize}
\end{frame}

\subsection{Term substitution issues}

\begin{frame}{Substitution definition - first attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} \\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{The names of bound variables do not matter}
        \begin{displaymath}
            \begin{split}
                [x \mapsto (\lambda z. z\, w)](\lambda y.x) &=
                     \lambda y.\lambda z.z\, w \quad \smiley \\
                [x \mapsto y](\lambda x.x) &= \lambda x.y \quad \frownie
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    We've not distinguished between \emph{free} occurrences of $x$ in a term $t$,
    which should get replaced during substitution, and \emph{bound} ones, which
    shouldn't.
\end{frame}

\begin{frame}{Substitution definition - second attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= {\color{red} \lambda y. t_{1} 
                    \quad \text{if } x = y}\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                    \quad {\color{red} \text{if } x \not = y}\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{Variable capture}
        \begin{displaymath}
            \begin{split}
                [x \mapsto y](\lambda x.x) &= \lambda x.x \quad \smiley \\
                [x \mapsto z](\lambda z.x) &= \lambda z.z \quad \frownie\\ 
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    To avoid it, we need to make sure that the bound variable names of $t$
    are kept distinct from the free variables of $s$.
\end{frame}

\begin{frame}{Substitution definition - third attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. t_{1} \quad 
                    \text{if } x = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                                    \quad \text{if } x \not = y 
                                    {\color{red}\wedge y \not \in FV(s)}\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{$[x \mapsto s]t$ isn't a total function}
        \begin{displaymath}
            \begin{split}
                [x \mapsto z](\lambda z.x) &\not = \lambda z.z \quad \smiley\\ 
                [x \mapsto z](\lambda z.x) &\quad \text{yields no term at all!} 
                    \quad \frownie\\
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    A common fix is to work with terms \emph{up to renaming of bound variables}.
\end{frame}

\begin{frame}{Substitution definition - final attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \begin{block}{Observation}
        Terms that differ only in the names of bound variables are 
        interchangeable in all contexts.
    \end{block}

    \pause

    Any $\lambda$-bound variable can be changed to another name (changing the body 
    consistently too) at any point where this is convenient.

    \begin{example}
        \begin{displaymath}
            \begin{split}
                [x \mapsto y \, z](\lambda y.x \, y) &
                    \text{ renames abstraction to } (\lambda w.x \, w)\\ 
                [x \mapsto y \, z](\lambda w.x \, w) &= \lambda w. y \, z \, w 
                    \quad \smiley\\
            \end{split}
        \end{displaymath}
    \end{example}

    \pause

    This observation makes $[x \mapsto s]t$ a total function: 
    whenever we have to apply it to arguments for which it is 
    undefined, we can rename the $\lambda$ abstraction bound variable
    in order to satisfy side conditions.
\end{frame}

\begin{frame}{Substitution definition - final attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                                    \quad \text{if } x \not = y 
                                    \wedge (y \not \in FV(s) 
                                    {\color{red} \text{ by renaming}})\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}
\end{frame}

\subsection{Nameless representation of terms}

\begin{frame}{De Bruijn's idea}
    Up to now we've worked with terms \emph{up to renaming of bound 
    variables}. This does mean that an abstraction term is a \emph{schema}
    term indeed, which could represent \emph{infinite} terms.
    \begin{displaymath}
        \lambda x:T.t \text{ is a term} \leftrightarrow 
            \forall x \not \in FV(t)
    \end{displaymath}
    \begin{itemize}
        \item it is good for theoretical reasoning \smiley
        \item do not supply a single representation of terms \frownie
    \end{itemize}
    \pause
    \begin{block}{De Bruijn's idea}
        Variable occurrences \emph{point} to their binders, rather 
        than referring to them by name.
    \end{block}
    Using this idea we abstract from \emph{variable names}, replacing names by
    natural numbers. Let $k \in \mathbb{N}$ then $k$ represents \emph{the variable 
    bound by the $k$-th enclosing $\lambda$, counting from the most nested abstraction}.
    \pause
    \begin{example}
        \begin{displaymath}
            \begin{split}
                \lambda x.x \quad & \text{transforms to} \quad \lambda.0\\
                \lambda s.\lambda z.s \, (s\,  z) \quad & 
                    \text{transforms to} \quad \lambda.\lambda.1\,  (1\,  0)
            \end{split}
        \end{displaymath}
    \end{example}
\end{frame}

\begin{frame}{New definition of terms}
    The new definition of \emph{nameless} terms is similar to the one given 
    before, the only difference is that we need to track of how many free
    variables can appear in each term.

    \begin{block}{Definition}
        The set of terms is defined as the smallest family of sets
        $\{\mathcal{T}_{0},\mathcal{T}_{1},\ldots\}$ such that:
        \begin{displaymath}  
           \begin{split} 
                k \in \{0, \ldots, n-1\} &\rightarrow k \in \mathcal{T}_n  \\
                t_{1} \in \mathcal{T}_{n+1} &\rightarrow \lambda.t \in \mathcal{T}_n  \\
                t_{1} \in \mathcal{T}_{n} \wedge t_{2} \in \mathcal{T}_{n}
                    &\rightarrow t_{1} \, t_{2} \in \mathcal{T}_n  \\
           \end{split} 
        \end{displaymath}  
    \end{block}
    For all $j \in \mathcal{T}_n$ we say that $j$ is a $n$-term and in $j$ 
    appear \emph{at most} $n$ different free variables (pay attention: this is
    not a constraint on the number of \emph{occurrences} of the free variables, that is
    $\lambda.\lambda.(3\, (3\, (1\, (2\, (0\, 3)))))\, ((3\, 1)\, 3) 
        \in \mathcal{T}_{4}$ where there are 6 free variables).
\end{frame}

\begin{frame}
    
    \begin{itemize}
        \item two ordinary terms $t_1, t_2$ are equivalent modulo renaming of bound 
            $\leftrightarrow$ $t_{1}, t_{2}$ have the same nameless 
            representation \smiley
        \item how to deal with terms containing free variables, 
            ie $\lambda x.y\, x$?\\
            {\footnotesize We know how far the binder of $x$ is , but we doesn't 
            for the binder of $y$...}
    \end{itemize}
    \pause
    \begin{block}{Naming context}
        A naming context is an assignment of natural numbers to variables names,
        more formally:
       \begin{displaymath} 
            \Gamma \subseteq \mathcal{V} \times \mathbb{N} 
       \end{displaymath} 
       where $\mathcal{V}$ is the set of variables.
    \end{block}
    \pause
    \begin{example}
        Let $\Gamma = \{ x \mapsto 4, y \mapsto 3, z \mapsto 2, a \mapsto 1, 
                        b \mapsto 0 \}$ be a naming context. We have:
        \begin{displaymath}
            \begin{split}
                x \, (y \, z) \quad &\text{transforms to} \quad 4 \, (3 \, 2)\\
                \lambda w.y \, w \quad &\text{transforms to} \quad 
                    \lambda. 4 \, 0 \quad (4?!)\\
                \lambda w.\lambda a.x \quad &\text{transforms to} \quad 
                    \lambda.\lambda. 6\quad (6?!)\\
            \end{split}
        \end{displaymath}
    \end{example}
\end{frame}

\begin{frame}{Shifting and substitution}
    Consider \emph{again} the rule:
        $(\lambda x.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$ 
        where $t_{12} = \lambda y.t, x\not=y$.
    \\~\\
    \pause
    
    When we can apply the substitution $[x \mapsto s]$ to an abstraction $\lambda.t$
    the context in which the substitution is happening introduces a $\lambda$, 
    in other word introduces a variable. \\
    \begin{block}{Shifting}
        In order to remain consistent within $s$, we have to increment the indices of 
        free variables appearing in $s$ by one, since we're introducing a 
        $\lambda$ binder between the free variables in $s$ and their binders.
        We call this increment operation, or \emph{shifting}, with $\uparrow^{1}(s)$.
    \end{block}
    \pause
    For the same reason that the abstraction $\lambda.t$ introduces a variable,
    we've to modify the definition of $[x \mapsto s]$, paying attention to increment
    x by one too because x isn't the variable bound by the context $\lambda.t$.
\end{frame}

\begin{frame}
    \begin{block}{Formal Substitution definition}
        The substitution of a term $s$ for a variable number $j$ in a term $t$,
        written as $[j \mapsto s]t$, is defined inductively as follows:
        \begin{displaymath}
            \begin{split}
                [j \mapsto s]k &= s \quad \text{if } k = j\\
                [j \mapsto s]k &= k \quad \text{if } k \not= j\\
                [j \mapsto s]\lambda.t_{1} &= 
                    \lambda.[j+1 \mapsto \uparrow^{1}(s)]t_{1} \\
                [j \mapsto s]t_1 \, t_2 &= ([j \mapsto s] t_1)\, ([j \mapsto s] t_2)
            \end{split}
        \end{displaymath}
    \end{block}
    \pause 
    \begin{block}{Formal Shifting definition}
        The $d$-place shift of a term $t$ above cutoff $c$,
        written as $\uparrow_{c}^{d}(t)$, is defined inductively as follows
        (where $\uparrow^{d}(t)$ stands for $\uparrow_{0}^{d}$):
        \begin{displaymath}
            \begin{split}
                \uparrow_{c}^{d}(k) &= k \quad \text{if } k < c\\
                \uparrow_{c}^{d}(k) &= k+d \quad \text{if } k \geq c\\
                \uparrow_{c}^{d}(\lambda.t_{1}) &= 
                    \lambda.\uparrow_{c+1}^{d}(t_{1}) \\
                \uparrow_{c}^{d}(t_1 \, t_2) &= \uparrow_{c}^{d}(t_1)\, 
                    \uparrow_{c}^{d}(t_2)
            \end{split}
        \end{displaymath}
    \end{block}
\end{frame}

\begin{frame}{Evaluation}
    Consider \emph{for the last time} the rule:
        $(\lambda x.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$ 
        where $t_{12} = \lambda y.t, x\not=y$.
    \\~\\
    \pause
    Reducing an abstraction $\lambda x.t_{12}$ make disappear the bound 
    variable $x$, so the resulting term $[x \mapsto v_{2}]t_{12}$ belong to 
    a smaller context (respect the number of $\lambda$ binders), hence we have to
    shift its free variables \emph{backward} by one.
    \\~\\
    \pause
    Similarly, in the resulting term we've to shift free 
    variables in $v_{2}$ \emph{forward} by one
    because the term $t_{12}$ is defined in a larger context (is protected by
    a $\lambda$-abstraction).
    \\~\\
    \pause
    Finally, we're interested to start substituting the inner most bound
    variable since this is our reduction strategy, so the initial index
    given to substitution function is $0$.
    \\~\\
    \pause
    \begin{block}{Modified reduction rule}
        \begin{displaymath}
            (\lambda.t_{12})\, v_{2} \rightarrow \uparrow^{-1}(
            [0 \mapsto \uparrow^{1}(v_{2})]t_{12})
        \end{displaymath}
    \end{block}
\end{frame}


\end{document}


% $Header:
% /home/vedranm/bitbucket/beamer/solutions/conference-talks/conference-ornate-20min.en.tex,v
% 90e850259b8b 2007/01/28 20:48:30 tantau $

\documentclass[8pt]{beamer}

% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.



% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 


\mode<presentation>
{
  \usetheme{Warsaw}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever
\usepackage{wasysym}
\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.
% \lstset{
%   language=XML,
%   basicstyle=\footnotesize,%\ttfamily,
%   columns=fullflexible,
%   morekeywords={encoding,
%     xs:schema,xs:element,xs:complexType,xs:sequence,xs:attribute}
% }

\title[Type reconstruction] {Type reconstruction}

\subtitle{constraint-based, unification and a little interpreter}

\author[Massimo Nocentini] % (optional, use only with lots of authors)
{Massimo~Nocentini\\\texttt{massimo.nocentini@gmail.com}}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

 \institute[UniversitaStudiFirenze] % (optional, but mostly needed)
 { Universit\`a degli Studi di Firenze }
%   \inst{1}%
%   Department of Computer Science\\
%   University of Somewhere
%   \and
%   \inst{2}%
%   Department of Theoretical Philosophy\\
%   University of Elsewhere}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[CoursePresentation] % (optional, should be abbreviation of conference name)
{Firenze, \today}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

\subject{Theory of Programming Languages}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=1.5cm]{university-logo}{logo/unifi}
% \logo{\pgfuseimage{university-logo}}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Contents}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}[plain]
  \titlepage
   \begin{center}
     \includegraphics[scale=.065]{logo/unifi}
   \end{center}
\end{frame}

\begin{frame}{Road map}
  \tableofcontents[pausesections]
  % You might wish to add the option [pausesections]
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\begin{frame}{Syntax review}
    \begin{block}{Terms}
        \begin{center}
            \begin{tabular}{ r l r }
              $t ::= $ & $x$ & \emph{variable} \\
               & $\lambda x:T.t$ & \emph{abstraction} \\
               & $t \, t$ & \emph{application} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Values}
        \begin{center}
            \begin{tabular}{ r l r }
              $v ::= $ & $\lambda x:T.t$ & \emph{abstraction value} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Types}
        \begin{center}
            \begin{tabular}{ r l r }
              $T ::= $ & $T \rightarrow T$ & \emph{function type} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Contexts}
        \begin{center}
            \begin{tabular}{ r l r }
              $\Gamma ::= $ & $\emptyset$ & \emph{empty context} \\
               & $\Gamma, x:T$ & \emph{variable binding} \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Evaluation rules review}
    \begin{block}{Evaluation rules}
        \begin{displaymath}
            \begin{split}
              {{t_{1} \rightarrow t_{1}^{\prime}}\over
                    {t_{1} \, t_{2} \rightarrow t_{1}^{\prime} \, t_{2}}} & \quad \text{E-App}_{1} \\
               {{t_{2} \rightarrow t_{2}^{\prime}}\over
                    {v_{1} \, t_{2} \rightarrow v_{1} \, t_{2}^{\prime}}} & \quad \text{E-App}_{2} \\
               (\lambda x:T_{11}.t_{12})v_{2} & \rightarrow [x \mapsto v_{2}]t_{12}  \quad \text{E-AppAbs} \\
            \end{split}
        \end{displaymath}
    \end{block}
\end{frame}

\begin{frame}{Typing rules review}
    \begin{block}{Typing rules}
        \begin{displaymath}
            \begin{split}
              {{x:T \in \Gamma}\over
                    {\Gamma \vdash x:T}} & \quad \text{T-Var} \\
              {{\Gamma, x:T_{1} \vdash t_{2}:T_{2}}\over
                    {\Gamma \vdash \lambda x:T_{1}.t_{2} : T_{1} \rightarrow T_{2}}} & \quad \text{T-Abs} \\
              {{\Gamma \vdash t_{1}:T_{11} \rightarrow T_{12} \quad \Gamma \vdash t_{2}:T_{11}}\over
                    {\Gamma \vdash t_{1} \, t_{2} : T_{12}}} & \quad \text{T-App} \\
            \end{split}
        \end{displaymath}
    \end{block}
\end{frame}

\section{Constrait-based typing}

\section{Unification}

\section{Interpreter}

\subsection{Lambda calculus grammar}

\begin{frame}{Grammar}
  \begin{block}{Definizione}
    The set T of terms representing the lambda calculus language is the
    smallest set generated by the following rules:
  \begin{displaymath}
    \begin{split}
      \text{Term} &\triangleq \text{AppTerm | ``lambda'' ID ``:'' Type ``.''
        ATerm}\\
      \text{AppTerm} &\triangleq \text{ATerm ATerm} \\
      \text{ATerm} &\triangleq \text{``('' Term ``)'' | ID}\\
      \text{Type} &\triangleq \text{ArrowType}\\
      \text{AType} &\triangleq \text{``('' Type ``)'' | ``Bool'' |
        ``Nat'' | ID}\\
      \text{ArrowType} &\triangleq \text{AType} (\rightarrow
      \text{ArrowType} | \text{AType})\\
    \end{split}
  \end{displaymath}
\end{block}
where:
\begin{itemize}
    \item $\Sigma$ is our alphabet;
    \item ID $\in \Sigma \setminus \{ \text{``lambda'', ``:'', ``.'',
  ``('', ``)'', ``Bool'', ``Nat''} \}$.
\end{itemize}

%\begin{center}
%  \includegraphics[scale=0.4]{images/graph-with-b-setted.eps}
%  \includegraphics[scale=0.4]{images/story-example.eps} 
%  \includegraphics[scale=0.4]{images/non-story-example.eps}
%\end{center} 
\end{frame}

\begin{frame}{Some observations}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
    We make the following observations:
      \begin{itemize}
        \item we design the grammar to be processed by \emph{ANTLR}, a $LL(k)$
            top-down parser;
        \item the grammar seen during lectures has left recursion on 
            $T-APP$ rule (good for LR bottom-up parser);
        \item our grammar maybe ``naive'' in the sense that allow to write 
            some strange terms (ie: \texttt{x (lambda y:Y. x)}) but for our 
            scope is enough;
        \item it allows to write some ``obscure'' terms (ie: 
            \texttt{lambda x:X.(x x)}) which we desire to prove not safe.
    \end{itemize}
\end{frame}

\subsection{Term substitution issues}

\begin{frame}{Substitution definition - first attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} \\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{The names of bound variables do not matter}
        \begin{displaymath}
            \begin{split}
                [x \mapsto (\lambda z. z\, w)](\lambda y.x) &=
                     \lambda y.\lambda z.z\, w \quad \smiley \\
                [x \mapsto y](\lambda x.x) &= \lambda x.y \quad \frownie
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    We've not distinguished between \emph{free} occurrences of $x$ in a term $t$,
    which should get replaced during substitution, and \emph{bound} ones, which
    shouldn't.
\end{frame}

\begin{frame}{Substitution definition - second attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. t_{1} \quad \text{if } x = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} \quad \text{if } x \not = y\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{Variable capture}
        \begin{displaymath}
            \begin{split}
                [x \mapsto y](\lambda x.x) &= \lambda x.x \quad \smiley \\
                [x \mapsto z](\lambda z.x) &= \lambda x.z \quad \frownie\\ 
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    To avoid it, we need to make sure that the bound variable names of $t$
    are kept distinct from the free variables of $s$.
\end{frame}

\begin{frame}{Substitution definition - third attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. t_{1} \quad \text{if } x = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                                    \quad \text{if } x \not = y \wedge y \not \in FV(s)\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{$[x \mapsto s]t$ isn't a total function}
        \begin{displaymath}
            \begin{split}
                [x \mapsto z](\lambda z.x) &\not = \lambda x.z \quad \smiley\\ 
                [x \mapsto z](\lambda z.x) &\quad \text{yields no term at all!} \quad \frownie\\
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    A common fix is to work with terms \emph{up to renaming of bound variables}.
\end{frame}

\begin{frame}{Substitution definition - final attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \begin{block}{Observation}
        Terms that differ only in the names of bound variables are 
        interchangeable in all contexts.
    \end{block}

    \pause

    Any $\lambda$-bound variable can be changed to another name (changing the body 
    consistently too) at any point where this is convenient.

    \begin{example}
        \begin{displaymath}
            \begin{split}
                [x \mapsto y \, z](\lambda y.x \, y) &
                    \text{ renames abstraction to } (\lambda w.x \, w)\\ 
                [x \mapsto y \, z](\lambda w.x \, w) &= \lambda w. y \, z \, w \quad \smiley\\
            \end{split}
        \end{displaymath}
    \end{example}

    \pause

    This observation makes $[x \mapsto s]t$ a total function: 
    whenever we have to apply it to arguments for which it is 
    undefined, we can rename the $\lambda$ abstraction bound variable
    in order to satisfy side conditions.
\end{frame}

\begin{frame}{Substitution definition - final attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                                    \quad \text{if } x \not = y 
                                    \wedge (y \not \in FV(s) \text{ by renaming})\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}
\end{frame}

\subsection{Nameless representation of terms}

\begin{frame}{Dalla rete al grafo}
  Data una reazione \emph{non reversibile} $r$ tale che $reagenti(r) =
  \{ r_{1}, \ldots, r_{n} \} \wedge prodotti(r) = \{ p_{1}, \ldots,
  p_{m} \}$, costruiamo il sotto grafo $reagenti(r) \times
  prodotti(r)$
    \begin{block}{Esempio}
      Se $reagenti(r) = \{ a, b, c, d \} \wedge prodotti(r) = \{a, e,
      f\}$ allora
%      \begin{figure}
%        \centering
%        \includegraphics[scale=.6]{images/non-reversible-reaction-example.dot.eps}
%        \label{fig:non-reversible-reaction-mapping}
%      \end{figure}
    \end{block}
\end{frame}

\subsection{Standard ML implementation}
% put here some comments on the implementation, the tool used and some
% final considerations.
\begin{frame}{Seed Compounds}
  \begin{itemize}
  \item cercare le componenti fortemente connesse
  \item selezionare vertici in componenti sorgenti come \emph{seed
      compounds}
  \end{itemize}
%  \begin{figure}
%    \includegraphics[scale=.35]{images/biology-scc-decomposition.eps}
%  \end{figure}

\end{frame}

\begin{frame}{Storie}
  \begin{block}{Definizione}
    Dato un grafo orientato $G = (\mathbb{B} \cup \mathbb{W}, E)$, una
    \emph{storia} \`e un sotto grafo aciclico $G' = (\mathbb{B} \cup
    \mathbb{W'}, E')$ di $G$ tale che $E' \subseteq E $ e
  \begin{displaymath}
    \mathbb{W'} = \{w \in \mathbb{W}: indeg(w) > 0 \wedge outdeg(w)
    > 0\}
  \end{displaymath}
\end{block}
$\mathbb{B}$: vertici a cui \`e permesso essere sorgenti o pozzi
%\begin{center}
%  \includegraphics[scale=0.4]{images/graph-with-b-setted.eps}
%  \includegraphics[scale=0.4]{images/story-example.eps} 
%  \includegraphics[scale=0.4]{images/non-story-example.eps}
%\end{center} 
\end{frame}

\section{Nostro contributo}

\subsection{Obiettivi}

\begin{frame}{Analizzare reti, costruire $\mathbb{B}$ e verificare il
    metodo}
Gli obiettivi del nostro lavoro sono:
\begin{itemize}
\item<1-> rappresentare una rete mediante un grafo\\
  \footnotesize{astraendo dai molti dettagli di \emph{SBML}}
\item<2-> fornire strumenti per analizzare insiemi di reti\\
  \footnotesize{per avere informazioni sui metaboliti che appaiono in
    pi\`u di una rete}
\item<3-> costruire in modo automatico l'insieme $\mathbb{B}$\\
  \footnotesize{sfruttando le informazioni di tutte le reti studiate}
\item<4-> verificare se il metodo \`e accettabile\\
  \footnotesize{per misurare la validit\`a di $\mathbb{B}$}
\end{itemize}
\end{frame}

\subsection{Metodologia}

\begin{frame}{Rappresentazione della rete con grafo}
%\begin{center} 
%  \includegraphics[scale=.3]{images/sbml-code-chunk.eps}
%  \includegraphics[scale=.4]{images/presentation-input-graph-all-whites.eps}
%\end{center}
\end{frame}

\subsection{Risultati}

\begin{frame}{Analisi delle reti}
%  \begin{center}
%    \includegraphics[scale=.5]{images/ResultViewer-table-with-average-row-selected-particular.eps}
%  \end{center}
Tutte le reti hanno una struttura a ``clessidra'':
\begin{itemize}
\item molte componenti \emph{sorgenti} contenenti pochi vertici
\item poche componenti \emph{intermedie} contenenti molti vertici
\item molte componenti \emph{pozzo} contenenti pochi vertici
\end{itemize}
\pause
\begin{alertblock}{Troppi vertici sorgenti e pozzi}
  L'obiettivo sarebbe stato averne pochi
\end{alertblock}
\end{frame}

\begin{frame}{Analisi dei vertici}
%  \begin{center}
%    \includegraphics[scale=.5]{images/ResultViewer-grouping-table-zoom}
%  \end{center}
  Studiando un insieme di reti, pi\`u del 10\% dei vertici non hanno
  un ruolo univoco
  \pause
  \begin{alertblock}{Incertezza sulla costruzione di $\mathbb{B}$}
    Vertici con pi\`u di un ruolo inducono incertezza sul decidere la
    loro appartenenza all'insieme $\mathbb{B}$
  \end{alertblock}
\end{frame}

\begin{frame}{Combinazione delle due analisi}
%  \begin{center}
%      \includegraphics[scale=.5]{images/many-models-with-b-refinement}
%  \end{center}
  Se consideriamo tutti i vertici che hanno un ruolo univoco rispetto
  ad un insieme di reti, \`e possibile raffinare ogni $\mathbb{B}$
  escludendo i vertici che non hanno un ruolo conforme
\end{frame}


\section*{Sommario}

\begin{frame}{Riepilogo}
  % Keep the summary *very short*.
    \begin{itemize}
    \item costruire l'insieme $\mathbb{B}$ in modo automatico
      attraverso le componenti fortemente connesse \emph{non} sembra
      produrre risultati soddisfacenti
    \item l'unico caso utile riguarda l'analisi di modelli singoli,
      anche se in molti casi rimangono molti vertici in $\mathbb{B}$
    \end{itemize}
\end{frame}

\begin{frame}{Ricerca delle componenti fortemente connesse}
  Attualmente l'insieme $\mathbb{B}$ viene costruito in base a
  osservazioni e studi \emph{empirici}, costituito da metaboliti con
  propriet\`a particolari.

  Per costruirlo in modo automatico partizioniamo la rete in
  componenti connesse in quanto:
\begin{itemize}
\item<2-> \`e difficile assegnare il ruolo ad ogni vertice studiando
  l'intera rete date le sue dimensioni
\item<3-> \`e possibile astrarre dai cicli ed identificare classi di
  metaboliti equivalenti
\item<4-> due metaboliti equivalenti si producono a vicenda, pertanto
  gli associamo il ruolo della componente che li contiene
\item<5-> se una componente \`e \emph{sorgente} o \emph{pozzo} nel
  ``meta grafo'' allora aggiungiamo i vertici che la compongono in
  $\mathbb{B}$
\end{itemize}
\end{frame}

\end{document}


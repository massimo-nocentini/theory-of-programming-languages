% $Header:
% /home/vedranm/bitbucket/beamer/solutions/conference-talks/conference-ornate-20min.en.tex,v
% 90e850259b8b 2007/01/28 20:48:30 tantau $

\documentclass[8pt]{beamer}

% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.



% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 


\mode<presentation>
{
  \usetheme{Warsaw}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever
\usepackage{wasysym}
\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.
% \lstset{
%   language=XML,
%   basicstyle=\footnotesize,%\ttfamily,
%   columns=fullflexible,
%   morekeywords={encoding,
%     xs:schema,xs:element,xs:complexType,xs:sequence,xs:attribute}
% }

\title[Type reconstruction] {Type reconstruction}

\subtitle{constraint-based, unification and a little interpreter}

\author[Massimo Nocentini] % (optional, use only with lots of authors)
{Massimo~Nocentini\\\texttt{massimo.nocentini@gmail.com}}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

 \institute[UniversitaStudiFirenze] % (optional, but mostly needed)
 { Universit\`a degli Studi di Firenze }
%   \inst{1}%
%   Department of Computer Science\\
%   University of Somewhere
%   \and
%   \inst{2}%
%   Department of Theoretical Philosophy\\
%   University of Elsewhere}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[CoursePresentation] % (optional, should be abbreviation of conference name)
{Firenze, \today}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

\subject{Theory of Programming Languages}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=1.5cm]{university-logo}{logo/unifi}
% \logo{\pgfuseimage{university-logo}}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Contents}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}[plain]
  \titlepage
   \begin{center}
     \includegraphics[scale=.065]{logo/unifi}
   \end{center}
\end{frame}

\begin{frame}{Road map}
  \tableofcontents[pausesections]
  % You might wish to add the option [pausesections]
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\begin{frame}{Syntax review}
    \begin{block}{Terms}
        \begin{center}
            \begin{tabular}{ r l r }
              $t ::= $ & $x$ & \emph{variable} \\
               & $\lambda x:T.t$ & \emph{abstraction} \\
               & $t \, t$ & \emph{application} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Values}
        \begin{center}
            \begin{tabular}{ r l r }
              $v ::= $ & $\lambda x:T.t$ & \emph{abstraction value} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Types}
        \begin{center}
            \begin{tabular}{ r l r }
              $T ::= $ & $T \rightarrow T$ & \emph{function type} \\
            \end{tabular}
        \end{center}
    \end{block}
    \begin{block}{Contexts}
        \begin{center}
            \begin{tabular}{ r l r }
              $\Gamma ::= $ & $\emptyset$ & \emph{empty context} \\
               & $\Gamma, x:T$ & \emph{variable binding} \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Evaluation rules review}
    \begin{block}{Evaluation rules}

        \begin{center}
            \begin{tabular}{ c r }
                    $\displaystyle {{t_{1} \rightarrow t_{1}^{\prime}}\over
                    {t_{1} \, t_{2} \rightarrow t_{1}^{\prime} \, t_{2}}}
                $ & (\emph{E-APP1}) \\ 
               & \\
               $\displaystyle{{t_{2} \rightarrow t_{2}^{\prime}}\over
                    {v_{1} \, t_{2} \rightarrow v_{1} \, t_{2}^{\prime}}}$ & (\emph{E-APP2}) \\
               & \\ 
               $\displaystyle(\lambda x:T_{11}.t_{12})v_{2} \rightarrow 
                [x \mapsto v_{2}]t_{12}$ & (\emph{E-APPABS}) \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Typing rules review}
    \begin{block}{Typing rules}
        \begin{center}
            \begin{tabular}{ c r }
                    $\displaystyle {{x:T \in \Gamma}\over
                    {\Gamma \vdash x:T}} $ & (\emph{T-VAR}) \\ 
               & \\
               $\displaystyle{{\Gamma, x:T_{1} \vdash t_{2}:T_{2}}\over
                    {\Gamma \vdash \lambda x:T_{1}.t_{2} : T_{1} 
                        \rightarrow T_{2}}} $ & (\emph{T-ABS}) \\
               & \\ 
               $\displaystyle{{\Gamma \vdash t_{1}:T_{11} \rightarrow T_{12} \quad \Gamma \vdash t_{2}:T_{11}}\over
                    {\Gamma \vdash t_{1} \, t_{2} : T_{12}}} $ & (\emph{T-APP}) \\
            \end{tabular}
        \end{center}
    \end{block}
\end{frame}

\section{Constrait-based typing}

\section{Unification}

\section{Interpreter}

\subsection{Lambda calculus grammar}

\begin{frame}{Grammar}
  \begin{block}{Definizione}
    The set T of terms representing the lambda calculus language is the
    smallest set generated by the following rules:
  \begin{displaymath}
    \begin{split}
      \text{Term} &\triangleq \text{AppTerm | ``lambda'' ID ``:'' Type ``.''
        ATerm}\\
      \text{AppTerm} &\triangleq \text{ATerm ATerm} \\
      \text{ATerm} &\triangleq \text{``('' Term ``)'' | ID}\\
      \text{Type} &\triangleq \text{ArrowType}\\
      \text{AType} &\triangleq \text{``('' Type ``)'' | ``Bool'' |
        ``Nat'' | ID}\\
      \text{ArrowType} &\triangleq \text{AType} (\rightarrow
      \text{ArrowType} | \text{AType})\\
    \end{split}
  \end{displaymath}
\end{block}
where:
\begin{itemize}
    \item $\Sigma$ is our alphabet;
    \item ID $\in \Sigma \setminus \{ \text{``lambda'', ``:'', ``.'',
  ``('', ``)'', ``Bool'', ``Nat''} \}$.
\end{itemize}

%\begin{center}
%  \includegraphics[scale=0.4]{images/graph-with-b-setted.eps}
%  \includegraphics[scale=0.4]{images/story-example.eps} 
%  \includegraphics[scale=0.4]{images/non-story-example.eps}
%\end{center} 
\end{frame}

\begin{frame}{Some observations}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
    We make the following observations:
      \begin{itemize}
        \item we design the grammar to be processed by \emph{ANTLR}, a $LL(k)$
            top-down parser;
        \item the grammar seen during lectures has left recursion on 
            $T-APP$ rule (good for LR bottom-up parser);
        \item our grammar maybe ``naive'' in the sense that allow to write 
            some strange terms (ie: \texttt{x (lambda y:Y. x)}) but for our 
            scope is enough;
        \item it allows to write some ``obscure'' terms (ie: 
            \texttt{lambda x:X.(x x)}) which we desire to prove not safe.
    \end{itemize}
\end{frame}

\subsection{Term substitution issues}

\begin{frame}{Substitution definition - first attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} \\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{The names of bound variables do not matter}
        \begin{displaymath}
            \begin{split}
                [x \mapsto (\lambda z. z\, w)](\lambda y.x) &=
                     \lambda y.\lambda z.z\, w \quad \smiley \\
                [x \mapsto y](\lambda x.x) &= \lambda x.y \quad \frownie
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    We've not distinguished between \emph{free} occurrences of $x$ in a term $t$,
    which should get replaced during substitution, and \emph{bound} ones, which
    shouldn't.
\end{frame}

\begin{frame}{Substitution definition - second attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= {\color{red} \lambda y. t_{1} 
                    \quad \text{if } x = y}\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                    \quad {\color{red} \text{if } x \not = y}\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{Variable capture}
        \begin{displaymath}
            \begin{split}
                [x \mapsto y](\lambda x.x) &= \lambda x.x \quad \smiley \\
                [x \mapsto z](\lambda z.x) &= \lambda x.z \quad \frownie\\ 
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    To avoid it, we need to make sure that the bound variable names of $t$
    are kept distinct from the free variables of $s$.
\end{frame}

\begin{frame}{Substitution definition - third attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \pause

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. t_{1} \quad \text{if } x = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                                    \quad \text{if } x \not = y 
                                    {\color{red}\wedge y \not \in FV(s)}\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}

    \pause

    \begin{alertblock}{$[x \mapsto s]t$ isn't a total function}
        \begin{displaymath}
            \begin{split}
                [x \mapsto z](\lambda z.x) &\not = \lambda x.z \quad \smiley\\ 
                [x \mapsto z](\lambda z.x) &\quad \text{yields no term at all!} \quad \frownie\\
            \end{split}
        \end{displaymath}
    \end{alertblock}
    \pause
    A common fix is to work with terms \emph{up to renaming of bound variables}.
\end{frame}

\begin{frame}{Substitution definition - final attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \begin{block}{Observation}
        Terms that differ only in the names of bound variables are 
        interchangeable in all contexts.
    \end{block}

    \pause

    Any $\lambda$-bound variable can be changed to another name (changing the body 
    consistently too) at any point where this is convenient.

    \begin{example}
        \begin{displaymath}
            \begin{split}
                [x \mapsto y \, z](\lambda y.x \, y) &
                    \text{ renames abstraction to } (\lambda w.x \, w)\\ 
                [x \mapsto y \, z](\lambda w.x \, w) &= \lambda w. y \, z \, w \quad \smiley\\
            \end{split}
        \end{displaymath}
    \end{example}

    \pause

    This observation makes $[x \mapsto s]t$ a total function: 
    whenever we have to apply it to arguments for which it is 
    undefined, we can rename the $\lambda$ abstraction bound variable
    in order to satisfy side conditions.
\end{frame}

\begin{frame}{Substitution definition - final attempt}

    Consider the abstraction application rule:
        $(\lambda x:T_{11}.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$

    \begin{block}{Definition of $[x \mapsto s]t$}
        The substitution of a term $s$ for a variable named $x$ in a term $t$,
        written as $[x \mapsto s]t$, is defined as follows:
        \begin{displaymath}
            \begin{split}
                [x \mapsto s]x &= s \\
                [x \mapsto s]y &= y \quad \text{if } x \not = y\\
                [x \mapsto s](\lambda y.t_{1}) &= \lambda y. [x \mapsto s]t_{1} 
                                    \quad \text{if } x \not = y 
                                    \wedge (y \not \in FV(s) 
                                    {\color{red} \text{ by renaming}})\\
                [x \mapsto s](t_{1} \, t_{2}) &= 
                    ([x \mapsto s]t_{1})\, ([x \mapsto s]t_{2})\\
            \end{split}
        \end{displaymath}        
    \end{block}
\end{frame}

\subsection{Nameless representation of terms}

\begin{frame}{De Bruijn's idea}
    Up to now we've worked with terms \emph{up to renaming of bound 
    variables}. This does mean that an abstraction term is a \emph{schema}
    term indeed, which could represent \emph{infinite} terms.
    \begin{displaymath}
        \lambda x:T.t \text{ is a term} \leftrightarrow 
            \forall x \not \in FV(t)
    \end{displaymath}
    \begin{itemize}
        \item it is good for theoretical reasoning \smiley
        \item do not supply a single representation of terms \frownie
    \end{itemize}
    \pause
    \begin{block}{De Bruijn's idea}
        Variable occurrences \emph{point} to their binders, rather 
        than referring to them by name.
    \end{block}
    Using this idea we abstract from \emph{variable names}, replacing names by
    natural numbers. Let $k \in \mathbb{N}$ then $k$ represents \emph{the variable 
    bound by the $k$-th enclosing $\lambda$, counting from the most nested abstraction}.
    \pause
    \begin{example}
        \begin{displaymath}
            \begin{split}
                \lambda x.x \quad & \text{transforms to} \quad \lambda.0\\
                \lambda s.\lambda z.s \, (s\,  z) \quad & 
                    \text{transforms to} \quad \lambda.\lambda.1\,  (1\,  0)
            \end{split}
        \end{displaymath}
    \end{example}
\end{frame}

\begin{frame}{New definition of terms}
    The new definition of \emph{nameless} terms is similar to the one given 
    before, the only difference is that we need to track of how many free
    variables can appear in each term.

    \begin{block}{Definition}
        The set of terms is defined as the smallest family of sets
        $\{\mathcal{T}_{0},\mathcal{T}_{1},\ldots\}$ such that:
        \begin{displaymath}  
           \begin{split} 
                k \in \{0, \ldots, n-1\} &\rightarrow k \in \mathcal{T}_n  \\
                t_{1} \in \mathcal{T}_{n+1} &\rightarrow \lambda.t \in \mathcal{T}_n  \\
                t_{1} \in \mathcal{T}_{n} \wedge t_{2} \in \mathcal{T}_{n}
                    &\rightarrow t_{1} \, t_{2} \in \mathcal{T}_n  \\
           \end{split} 
        \end{displaymath}  
    \end{block}
    For all $j \in \mathcal{T}_n$ we say that $j$ is a $n$-term and in $j$ 
    appear \emph{at most} $n$ different free variables (pay attention: this is
    not a constraint on the number of \emph{occurrences} of the free variables, that is
    $\lambda.\lambda.(3\, (3\, (1\, (2\, (0\, 3)))))\, ((3\, 1)\, 3) 
        \in \mathcal{T}_{4}$ where there are 6 free variables).
\end{frame}

\begin{frame}
    
    \begin{itemize}
        \item two ordinary terms $t_1, t_2$ are equivalent modulo renaming of bound 
            $\leftrightarrow$ $t_{1}, t_{2}$ have the same nameless 
            representation \smiley
        \item how to deal with terms containing free variables, 
            ie $\lambda x.y\, x$?\\
            {\footnotesize We know how far the binder of $x$ is , but we doesn't 
            for the binder of $y$...}
    \end{itemize}
    \pause
    \begin{block}{Naming context}
        A naming context is an assignment of natural numbers to variables names,
        more formally:
       \begin{displaymath} 
            \Gamma \subseteq \mathcal{V} \times \mathbb{N} 
       \end{displaymath} 
       where $\mathcal{V}$ is the set of variables.
    \end{block}
    \pause
    \begin{example}
        Let $\Gamma = \{ x \mapsto 4, y \mapsto 3, z \mapsto 2, a \mapsto 1, 
                        b \mapsto 0 \}$ be a naming context. We have:
        \begin{displaymath}
            \begin{split}
                x \, (y \, z) \quad &\text{transforms to} \quad 4 \, (3 \, 2)\\
                \lambda w.y \, w \quad &\text{transforms to} \quad 
                    \lambda. 4 \, 0 \quad (4?!)\\
                \lambda w.\lambda a.x \quad &\text{transforms to} \quad 
                    \lambda.\lambda. 6\quad (6?!)\\
            \end{split}
        \end{displaymath}
    \end{example}
\end{frame}

\begin{frame}{Shifting and substitution}
    Consider \emph{again} the rule:
        $(\lambda x.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$ 
        where $t_{12} = \lambda y.t, x\not=y$.
    \\~\\
    \pause
    
    When we can apply the substitution $[x \mapsto s]$ to an abstraction $\lambda.t$
    the context in which the substitution is happening introduces a $\lambda$, 
    in other word introduces a variable. \\
    \begin{block}{Shifting}
        In order to remain consistent within $s$, we have to increment the indices of 
        free variables appearing in $s$ by one, since we're introducing a 
        $\lambda$ binder between the free variables in $s$ and their binders.
        We call this increment operation, or \emph{shifting}, with $\uparrow^{1}(s)$.
    \end{block}
    \pause
    For the same reason that the abstraction $\lambda.t$ introduces a variable,
    we've to modify the definition of $[x \mapsto s]$, paying attention to increment
    x by one too because x isn't the variable bound by the context $\lambda.t$.
\end{frame}

\begin{frame}
    \begin{block}{Formal Substitution definition}
        The substitution of a term $s$ for a variable number $j$ in a term $t$,
        written as $[j \mapsto s]t$, is defined inductively as follows:
        \begin{displaymath}
            \begin{split}
                [j \mapsto s]k &= s \quad \text{if } k = j\\
                [j \mapsto s]k &= k \quad \text{if } k \not= j\\
                [j \mapsto s]\lambda.t_{1} &= 
                    \lambda.[j+1 \mapsto \uparrow^{1}(s)]t_{1} \\
                [j \mapsto s]t_1 \, t_2 &= ([j \mapsto s] t_1)\, ([j \mapsto s] t_2)
            \end{split}
        \end{displaymath}
    \end{block}
    \pause 
    \begin{block}{Formal Shifting definition}
        The $d$-place shift of a term $t$ above cutoff $c$,
        written as $\uparrow_{c}^{d}(t)$, is defined inductively as follows
        (where $\uparrow^{d}(t)$ stands for $\uparrow_{0}^{d}$):
        \begin{displaymath}
            \begin{split}
                \uparrow_{c}^{d}(k) &= k \quad \text{if } k < c\\
                \uparrow_{c}^{d}(k) &= k+d \quad \text{if } k \geq c\\
                \uparrow_{c}^{d}(\lambda.t_{1}) &= 
                    \lambda.\uparrow_{c+1}^{d}(t_{1}) \\
                \uparrow_{c}^{d}(t_1 \, t_2) &= \uparrow_{c}^{d}(t_1)\, 
                    \uparrow_{c}^{d}(t_2)
            \end{split}
        \end{displaymath}
    \end{block}
\end{frame}

\begin{frame}{Evaluation}
    Consider \emph{for the last time} the rule:
        $(\lambda x.t_{12})v_{2} \rightarrow [x \mapsto v_{2}]t_{12}$ 
        where $t_{12} = \lambda y.t, x\not=y$.
    \\~\\
    \pause
    Reducing an abstraction $\lambda x.t_{12}$ make disappear the bound 
    variable $x$, so the resulting term $[x \mapsto v_{2}]t_{12}$ belong to 
    a smaller context (respect the number of $\lambda$ binders), hence we have to
    shift its free variables \emph{backward} by one.
    \\~\\
    \pause
    Similarly, in the resulting term we've to shift free 
    variables in $v_{2}$ \emph{forward} by one
    because the term $t_{12}$ is defined in a larger context (is protected by
    a $\lambda$-abstraction).
    \\~\\
    \pause
    Finally, we're interested to start substituting the inner most bound
    variable since this is our reduction strategy, so the initial index
    given to substitution function is $0$.
    \\~\\
    \pause
    \begin{block}{Modified reduction rule}
        \begin{displaymath}
            (\lambda.t_{12})\, v_{2} \rightarrow \uparrow^{-1}(
            [0 \mapsto \uparrow^{1}(v_{2})]t_{12})
        \end{displaymath}
    \end{block}
\end{frame}


\end{document}

